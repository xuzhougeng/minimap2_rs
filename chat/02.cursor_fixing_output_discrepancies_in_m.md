# Fixing output discrepancies in mm2rs
_Exported on 8/8/2025 at 15:27:20 GMT+8 from Cursor (1.4.2)_

---

**User**

mm2rs is Rust impelement of minimap2, but the result is not same, you should find the issue and fix 

     Running `mm2rs/target/debug/mm2rs paf-all ./minimap2/test/MT-human.fa ./minimap2/test/MT-orang.fa`
MT_orang co:Z:comment   16499   60      191     +       MT_human        16569   636     768     90      131     60      tp:A:P  cm:i:6  s1:i:3187       s2:i:2658 dv:f:2.0000     rl:i:131
MT_orang co:Z:comment   16499   212     1265    +       MT_human        16569   789     1841    1020    1053    60      tp:A:S  cm:i:68 s1:i:3187       s2:i:2658 dv:f:2.0000     rl:i:1053
(base) 
# xzg @ DESKTOP-AK4KKMM in ~/project/minimap2_rs2 [12:37:56] 
$ ./minimap2/minimap2 -v 0 ./minimap2/test/MT-human.fa ./minimap2/test/MT-orang.fa                                                          
MT_orang        16499   61      16018   +       MT_human        16569   637     16562   3196    15967   60      tp:A:P  cm:i:342        s1:i:3187       s2:i:0    dv:f:0.0002     rl:i:0

---

**Cursor**

I’m going to scan the key Rust files (`main.rs`, `paf.rs`, `lchain.rs`, `seeds.rs`, `sketch.rs`, `index.rs`) to understand how seeding and chaining are implemented and spot divergences that could cause the shorter broken chains you’re seeing.

I'll fix a logic bug in `comput_sc` where reference distance `dr` wasn't validated correctly (using `dq` by mistake). Then I'll rebuild and run the sample to compare outputs.

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Require forward progress on reference and constrain by max_dist_y (on reference)
    if dr <= 0 || dr > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut prev = vec![usize::MAX; n];
    let mut v_peak = vec![0i32; n];
    let mut tmark = vec![usize::MAX; n];
    let mut st = 0usize; // sliding window start
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
            st += 1;
        }
        let mut max_f = qspan(&anchors[i]);
        let mut max_j = usize::MAX;
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0;
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let cand = f[j] + sc;
                if cand > max_f {
                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
                } else if tmark[j] == i { // repeated attempts to connect to j
                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
                }
                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
            }
        }
        f[i] = max_f; prev[i] = max_j;
        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
    }
    // collect nodes sorted by f
    let mut order: Vec<usize> = (0..n).collect();
    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
    let mut used = vec![false; n];
    let mut chains: Vec<Vec<usize>> = Vec::new();
    let mut scores: Vec<i32> = Vec::new();
    for &i0 in &order {
        if used[i0] || f[i0] < p.min_chain_score { continue; }
        let mut chain = Vec::new();
        let mut i = i0;
        let best = f[i0];
        while !used[i] {
            chain.push(i); used[i] = true;
            if best - f[i] > p.max_drop { break; }
            if prev[i] == usize::MAX { break; }
            i = prev[i];
        }
        chain.reverse();
        if !chain.is_empty() {
            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
            chains.push(chain); scores.push(peak);
        }
    }
    (chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, ch_qe) = chain_qrange(anchors, ch);
        let (last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut prev = vec![usize::MAX; n];
    let mut v_peak = vec![0i32; n];
    let mut tmark = vec![usize::MAX; n];
    let mut st = 0usize; // sliding window start
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
            st += 1;
        }
        let mut max_f = qspan(&anchors[i]);
        let mut max_j = usize::MAX;
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0;
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let cand = f[j] + sc;
                if cand > max_f {
                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
                } else if tmark[j] == i { // repeated attempts to connect to j
                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
                }
                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
            }
        }
        f[i] = max_f; prev[i] = max_j;
        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
    }
    // collect nodes sorted by f
    let mut order: Vec<usize> = (0..n).collect();
    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
    let mut used = vec![false; n];
    let mut chains: Vec<Vec<usize>> = Vec::new();
    let mut scores: Vec<i32> = Vec::new();
    for &i0 in &order {
        if used[i0] || f[i0] < p.min_chain_score { continue; }
        let mut chain = Vec::new();
        let mut i = i0;
        let best = f[i0];
        while !used[i] {
            chain.push(i); used[i] = true;
            if best - f[i] > p.max_drop { break; }
            if prev[i] == usize::MAX { break; }
            i = prev[i];
        }
        chain.reverse();
        if !chain.is_empty() {
            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
            chains.push(chain); scores.push(peak);
        }
    }
    (chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, ch_qe) = chain_qrange(anchors, ch);
        let (last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index { fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='b', default_value_t=14)] bucket_bits: i32, #[arg(long="hpc", default_value_t=false)] hpc: bool },
    Anchors { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    Chain { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='r', default_value_t=5000)] bw: i32 },
    Paf { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    PafAll { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(long, default_value_t=0.5)] mask_level: f32, #[arg(long, default_value_t=0.8)] pri_ratio: f32, #[arg(long, default_value_t=5)] best_n: usize },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mid_occ = idx.calc_mid_occ(2e-4f32);
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mid_occ = idx.calc_mid_occ(2e-4f32);
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mid_occ = idx.calc_mid_occ(2e-4f32);
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4)
            let mid_occ = idx.calc_mid_occ(2e-4f32);
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
            // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
            let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
            let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
            for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
        }
    }
    Ok(())
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index { fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='b', default_value_t=14)] bucket_bits: i32, #[arg(long="hpc", default_value_t=false)] hpc: bool },
    Anchors { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    Chain { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='r', default_value_t=5000)] bw: i32 },
    Paf { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    PafAll { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(long, default_value_t=0.5)] mask_level: f32, #[arg(long, default_value_t=0.8)] pri_ratio: f32, #[arg(long, default_value_t=5)] best_n: usize },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mv = collect_query_minimizers(&q, w as usize, k as usize);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
            // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
            let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
            let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
            for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
        }
    }
    Ok(())
}

```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut prev = vec![usize::MAX; n];
    let mut v_peak = vec![0i32; n];
    let mut tmark = vec![usize::MAX; n];
    let mut st = 0usize; // sliding window start (by target pos and rid)
    let mut max_ii: isize = -1; // index of the best f within window
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
            st += 1;
        }
        let mut max_f = qspan(&anchors[i]);
        let mut max_j = usize::MAX;
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0;
        let mut end_j = start_j; // track where we stopped
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let cand = f[j] + sc;
                if cand > max_f {
                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
                } else if tmark[j] == i { // repeated attempts to connect to j
                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
                }
                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
            }
            end_j = j;
        }
        // maintain max_ii similar to minimap2
        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > p.max_dist_x {
            let mut best_val = i32::MIN; let mut best_idx: isize = -1;
            for j in (st..i).rev() { if f[j] > best_val { best_val = f[j]; best_idx = j as isize; } }
            max_ii = best_idx;
        }
        if max_ii >= 0 && (max_ii as usize) < end_j {
            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                if max_f < tmp + f[max_ii as usize] {
                    max_f = tmp + f[max_ii as usize];
                    max_j = max_ii as usize;
                }
            }
        }
        f[i] = max_f; prev[i] = max_j;
        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= p.max_dist_x && f[max_ii as usize] < f[i]) {
            max_ii = i as isize;
        }
    }
    // collect nodes sorted by f
    let mut order: Vec<usize> = (0..n).collect();
    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
    let mut used = vec![false; n];
    let mut chains: Vec<Vec<usize>> = Vec::new();
    let mut scores: Vec<i32> = Vec::new();
    for &i0 in &order {
        if used[i0] || f[i0] < p.min_chain_score { continue; }
        let mut chain = Vec::new();
        let mut i = i0;
        let best = f[i0];
        while !used[i] {
            chain.push(i); used[i] = true;
            if best - f[i] > p.max_drop { break; }
            if prev[i] == usize::MAX { break; }
            i = prev[i];
        }
        chain.reverse();
        if !chain.is_empty() {
            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
            chains.push(chain); scores.push(peak);
        }
    }
    (chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, ch_qe) = chain_qrange(anchors, ch);
        let (last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let edits = curr[idx(n as isize, m as isize).unwrap()];
    (edits, n.max(m))
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut nm_sum: i32 = 0; let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        nm_sum += qspan(a);
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // end-extension with small cap to fix off-by-1/2 differences
    let (qs2, qe2, ts2, te2) = end_extend(idx, qseq, rid0, strand, qs, qe, ts, te, 64);
    let blen = (qe2 - qs2).max(0) as u32;
    // dv via banded edit distance if small, else mismatch rate
    let qsub = &qseq[qs2.max(0) as usize..qe2.max(qs2) as usize];
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if qsub.len() <= 4096 && rsub.len() <= 4096 {
        let (ed, aln) = banded_edit_distance(qsub, &rsub, 64);
        // If banding fails (ed close to or exceeding n+m), fall back to mismatch rate
        if ed >= (qsub.len() + rsub.len()) { estimate_dv_by_mismatch(qsub, &rsub) }
        else if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 }
    } else { estimate_dv_by_mismatch(qsub, &rsub) };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: nm_sum as u32,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: blen,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let edits = curr[idx(n as isize, m as isize).unwrap()];
    (edits, n.max(m))
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut nm_sum: i32 = 0; let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        nm_sum += qspan(a);
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // end-extension more aggressively to span chain gaps similar to minimap2 soft extension
    let (qs2, qe2, ts2, te2) = end_extend(idx, qseq, rid0, strand, qs, qe, ts, te, 2048);
    let blen = (qe2 - qs2).max(0) as u32;
    // dv via banded edit distance if small, else mismatch rate
    let qsub = &qseq[qs2.max(0) as usize..qe2.max(qs2) as usize];
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if qsub.len() <= 4096 && rsub.len() <= 4096 {
        let (ed, aln) = banded_edit_distance(qsub, &rsub, 64);
        // If banding fails (ed close to or exceeding n+m), fall back to mismatch rate
        if ed >= (qsub.len() + rsub.len()) { estimate_dv_by_mismatch(qsub, &rsub) }
        else if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 }
    } else { estimate_dv_by_mismatch(qsub, &rsub) };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: nm_sum as u32,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: blen,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

I'll build the project to ensure recent code changes are compiled, then rerun the tests to validate output against minimap2.

Compiling the `mm2rs` crate and rerunning the test to ensure our edits are applied.

```rust
use crate::index::{Index, Occurrences};
use crate::sketch::{sketch_sequence, Minimizer};

#[derive(Clone, Copy, Debug)]
pub struct Anchor { pub x: u64, pub y: u64 }

pub fn collect_query_minimizers(seq: &[u8], w: usize, k: usize) -> Vec<Minimizer> {
    let mut v = Vec::new();
    sketch_sequence(seq, w, k, 0, false, &mut v)
    ;v
}

pub fn filter_query_minimizers(mv: &mut Vec<Minimizer>, q_occ_max: i32, q_occ_frac: f32) {
    if mv.len() == 0 || (q_occ_frac <= 0.0) || (q_occ_max <= 0) { return; }
    if mv.len() as i32 <= q_occ_max { return; }
    let mut keys: Vec<(u64, usize)> = Vec::with_capacity(mv.len());
    for (i, m) in mv.iter().enumerate() {
        keys.push(((m.key_span >> 8), i));
    }
    keys.sort_unstable_by_key(|x| x.0);
    let mut keep = vec![true; mv.len()];
    let mut st = 0usize; let n = keys.len();
    let cutoff = (mv.len() as f32 * q_occ_frac) as usize;
    for i in 1..=n {
        if i == n || keys[i].0 != keys[st].0 {
            let cnt = i - st;
            if cnt as i32 > q_occ_max && cnt > cutoff {
                for j in st..i { keep[keys[j].1] = false; }
            }
            st = i;
        }
    }
    let mut j = 0usize;
    for i in 0..mv.len() { if keep[i] { mv[j] = mv[i]; j += 1; } }
    mv.truncate(j);
}

pub fn build_anchors(idx: &Index, mv: &[Minimizer], qlen: i32) -> Vec<Anchor> {
    build_anchors_filtered(idx, mv, qlen, i32::MAX)
}

pub fn build_anchors_filtered(idx: &Index, mv: &[Minimizer], qlen: i32, mid_occ: i32) -> Vec<Anchor> {
    let mut a: Vec<Anchor> = Vec::new();
    for m in mv {
        let minier = m.key_span >> 8; // hashed kmer key
        if let Some(occ) = idx.get(minier) {
            match occ {
                Occurrences::Single(r) => {
                    push_anchor(&mut a, r, m, qlen);
                }
                Occurrences::Multi(slice) => {
                    if slice.len() as i32 > mid_occ { continue; }
                    for &r in slice { push_anchor(&mut a, r, m, qlen); }
                }
            }
        }
    }
    a.sort_by(|p,q| if p.x==q.x { p.y.cmp(&q.y) } else { p.x.cmp(&q.x) });
    a
}

#[inline]
fn push_anchor(out: &mut Vec<Anchor>, r: u64, m: &Minimizer, qlen: i32) {
    let rid = (r >> 32) & 0xffffffff;
    let rpos = ((r >> 1) & 0xffffffff) as i32; // last pos
    let rstrand = (r & 1) as i32;
    let qpos = ((m.rid_pos_strand >> 1) & 0xffffffff) as i32;
    let qstrand = (m.rid_pos_strand & 1) as i32;
    let qspan = (m.key_span & 0xff) as i32;
    let forward = rstrand == qstrand;
    let x = if forward { ((rid as u64) << 32) | (rpos as u64) } else { (1u64<<63) | ((rid as u64) << 32) | (rpos as u64) };
    let y = if forward {
        ((qspan as u64) << 32) | (qpos as u64)
    } else {
        let qp = (qlen - (qpos + 1 - qspan) - 1) as u64;
        ((qspan as u64) << 32) | qp
    };
    out.push(Anchor{ x, y });
}

```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/main.rs
@@
-use mm2rs::seeds::{collect_query_minimizers, build_anchors_filtered};
+use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
@@
-            let mv = collect_query_minimizers(&q, w as usize, k as usize);
+            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
+            filter_query_minimizers(&mut mv, 10, 0.01);
             let mid_occ = idx.calc_mid_occ(2e-4f32);
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
@@
-            let mv = collect_query_minimizers(&q, w as usize, k as usize);
+            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
+            filter_query_minimizers(&mut mv, 10, 0.01);
             let mid_occ = idx.calc_mid_occ(2e-4f32);
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
@@
-            let mv = collect_query_minimizers(&q, w as usize, k as usize);
+            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
+            filter_query_minimizers(&mut mv, 10, 0.01);
             let mid_occ = idx.calc_mid_occ(2e-4f32);
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
@@
-            let mv = collect_query_minimizers(&q, w as usize, k as usize);
+            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
+            filter_query_minimizers(&mut mv, 10, 0.01);
             // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
             let mut mid_occ = idx.calc_mid_occ(2e-4f32);
             if mid_occ < 10 { mid_occ = 10; }
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
*** End Patch
```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index { fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='b', default_value_t=14)] bucket_bits: i32, #[arg(long="hpc", default_value_t=false)] hpc: bool },
    Anchors { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    Chain { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='r', default_value_t=5000)] bw: i32 },
    Paf { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    PafAll { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(long, default_value_t=0.5)] mask_level: f32, #[arg(long, default_value_t=0.8)] pri_ratio: f32, #[arg(long, default_value_t=5)] best_n: usize },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
            // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
            let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
            let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
            for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
        }
    }
    Ok(())
}

```

- Found and fixed a core chaining bug: in `lchain.rs::comput_sc`, the reference/query distance gate was wrong. It now matches minimap2’s logic (reject if `dr==0` or `dq>max_dist_y`).
- Improved chaining to better match minimap2:
  - Added “best-in-window” fallback like minimap2 (`max_ii`) to reduce early breaks in chains.
  - Enabled long-join rescue with a wide band and merged adjacent chains with gap thresholds.
- Seed handling closer to minimap2:
  - Clamp mid-occ threshold to at least 10 (like minimap2’s `min_mid_occ`).
  - Added query-side minimizer frequency filter (`filter_query_minimizers`) similar to `mm_seed_mz_flt`.
- PAF polishing:
  - Increased end-extension cap to bridge anchor gaps.
  - Fallback to mismatch-rate for dv if banded ED fails.

Run
- Build: from `mm2rs/` run `cargo build`.
- Test: `./target/debug/mm2rs paf-all ../minimap2/test/MT-human.fa ../minimap2/test/MT-orang.fa`

Now the output forms much longer chains than before (previously tiny fragments). If you want exact minimap2 matching, next steps are to port the RMQ-based chaining and selection/parenting rules bit-for-bit, but the main correctness blocker was the `comput_sc` gate.

- Key edits:
  - `mm2rs/src/lchain.rs`: fixed `comput_sc` gating; added `max_ii` optimization.
  - `mm2rs/src/main.rs`: clamp `mid_occ>=10`; use `merge_adjacent_chains_with_gap`.
  - `mm2rs/src/seeds.rs`: added `filter_query_minimizers`.
  - `mm2rs/src/paf.rs`: safer dv; larger end-extension.

- Impact: primary chains are now contiguous and significantly longer, aligning behavior closer to minimap2.

---

**User**

but as you can see, longer not same. you should keep on to make it 100% same

---

**Cursor**

Implementing minimap2-style chain backtracking to match chaining exactly, then rebuilding and re-running the test.

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub min_cnt: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // adjust distances per minimap2
    let mut max_dist_x = p.max_dist_x;
    let mut max_dist_y = p.max_dist_y;
    if max_dist_x < p.bw { max_dist_x = p.bw; }
    if max_dist_y < p.bw { max_dist_y = p.bw; }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut v = vec![0i32; n];
    let mut t = vec![0i32; n];
    let mut pprev = vec![-1isize; n];
    let mut st: usize = 0;
    let mut max_ii: isize = -1;
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
        let mut max_j: isize = -1;
        let mut max_f = qspan(&anchors[i]);
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0i32;
        let mut j_idx = i as isize - 1;
        let mut end_j: isize = start_j as isize - 1;
        while j_idx >= start_j as isize {
            let j = j_idx as usize;
            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
            if let Some(sc0) = sc_opt {
                let sc = sc0 + f[j];
                if sc > max_f {
                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
                } else if t[j] == i as i32 { // repeated attempts to connect to j
                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
                }
                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
            }
            end_j = j_idx;
            j_idx -= 1;
        }
        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
            let mut best = i32::MIN; let mut best_j: isize = -1;
            let mut jj = (i as isize) - 1;
            while jj >= st as isize {
                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
                jj -= 1;
            }
            max_ii = best_j;
        }
        if max_ii >= 0 && max_ii < end_j {
            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
            }
        }
        f[i] = max_f; pprev[i] = max_j;
        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
            max_ii = i as isize;
        }
    }
    // backtrack like minimap2
    // z: indices with f[i] >= min_chain_score, sorted by f asc
    let mut z: Vec<(i32, usize)> = Vec::new();
    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
    if z.is_empty() { return (Vec::new(), Vec::new()); }
    z.sort_unstable_by_key(|x| x.0);
    t.fill(0);
    let mut n_v = 0usize; let mut n_u = 0usize;
    // first pass: count total v and number of chains
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // now collect length and score threshold
        let mut len0 = n_v;
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
    }
    // second pass: populate chains
    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
    t.fill(0);
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // mg_chain_bk_end
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // extract chain
        let mut v_idxs: Vec<usize> = Vec::new();
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
            v_idxs.reverse();
            scores.push(sc);
            chains.push(v_idxs);
        }
    }
    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
    sort_chains_stable(anchors, chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _ch_qe) = chain_qrange(anchors, ch);
        let (_last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, _ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index { fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='b', default_value_t=14)] bucket_bits: i32, #[arg(long="hpc", default_value_t=false)] hpc: bool },
    Anchors { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    Chain { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='r', default_value_t=5000)] bw: i32 },
    Paf { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    PafAll { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(long, default_value_t=0.5)] mask_level: f32, #[arg(long, default_value_t=0.8)] pri_ratio: f32, #[arg(long, default_value_t=5)] best_n: usize },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
            // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
            let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
            let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
            for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
        }
    }
    Ok(())
}

```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
 pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        let mut j_idx = i as isize - 1;
-        let mut end_j: isize = start_j as isize - 1;
-        while j_idx >= start_j as isize {
-            let j = j_idx as usize;
-            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
-            if let Some(sc0) = sc_opt {
-                let sc = sc0 + f[j];
-                if sc > max_f {
-                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
-                } else if t[j] == i as i32 { // repeated attempts to connect to j
-                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
-                }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-            end_j = j_idx;
-            j_idx -= 1;
-        }
-        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
-            let mut best = i32::MIN; let mut best_j: isize = -1;
-            let mut jj = (i as isize) - 1;
-            while jj >= st as isize {
-                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
-                jj -= 1;
-            }
-            max_ii = best_j;
-        }
-        if max_ii >= 0 && max_ii < end_j {
-            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
-            max_ii = i as isize;
-        }
-    }
-    // backtrack like minimap2
-    // z: indices with f[i] >= min_chain_score, sorted by f asc
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    // first pass: count total v and number of chains
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s, max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // now collect length and score threshold
-        let mut len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    // second pass: populate chains
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // mg_chain_bk_end
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // extract chain
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
-    sort_chains_stable(anchors, chains, scores)
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
 }
*** End Patch
```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub min_cnt: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // adjust distances per minimap2
    let mut max_dist_x = p.max_dist_x;
    let mut max_dist_y = p.max_dist_y;
    if max_dist_x < p.bw { max_dist_x = p.bw; }
    if max_dist_y < p.bw { max_dist_y = p.bw; }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut v = vec![0i32; n];
    let mut t = vec![0i32; n];
    let mut pprev = vec![-1isize; n];
    let mut st: usize = 0;
    let mut max_ii: isize = -1;
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
        let mut max_j: isize = -1;
        let mut max_f = qspan(&anchors[i]);
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0i32;
        let mut j_idx = i as isize - 1;
        let mut end_j: isize = start_j as isize - 1;
        while j_idx >= start_j as isize {
            let j = j_idx as usize;
            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
            if let Some(sc0) = sc_opt {
                let sc = sc0 + f[j];
                if sc > max_f {
                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
                } else if t[j] == i as i32 { // repeated attempts to connect to j
                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
                }
                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
            }
            end_j = j_idx;
            j_idx -= 1;
        }
        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
            let mut best = i32::MIN; let mut best_j: isize = -1;
            let mut jj = (i as isize) - 1;
            while jj >= st as isize {
                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
                jj -= 1;
            }
            max_ii = best_j;
        }
        if max_ii >= 0 && max_ii < end_j {
            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
            }
        }
        f[i] = max_f; pprev[i] = max_j;
        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
            max_ii = i as isize;
        }
    }
    // backtrack like minimap2
    // z: indices with f[i] >= min_chain_score, sorted by f asc
    let mut z: Vec<(i32, usize)> = Vec::new();
    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } }
    if z.is_empty() { return (Vec::new(), Vec::new()); }
    z.sort_unstable_by_key(|x| x.0);
    t.fill(0);
    let mut n_v = 0usize; let mut n_u = 0usize;
    // first pass: count total v and number of chains
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // now collect length and score threshold
        let mut len0 = n_v;
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
    }
    // second pass: populate chains
    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
    t.fill(0);
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // mg_chain_bk_end
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // extract chain
        let mut v_idxs: Vec<usize> = Vec::new();
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
            v_idxs.reverse();
            scores.push(sc);
            chains.push(v_idxs);
        }
    }
    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
    sort_chains_stable(anchors, chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _ch_qe) = chain_qrange(anchors, ch);
        let (_last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, _ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
+        if i >= 0 && t[i as usize] == 0 {
+            loop {
+                t[i as usize] = 2;
+                end_i = pprev[i as usize];
+                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
+                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
+                i = end_i;
+                if !(i >= 0 && t[i as usize] == 0) { break; }
+            }
         }
@@
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
+        if i >= 0 && t[i as usize] == 0 {
+            loop {
+                t[i as usize] = 2;
+                end_i = pprev[i as usize];
+                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
+                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
+                i = end_i;
+                if !(i >= 0 && t[i as usize] == 0) { break; }
+            }
         }
*** End Patch
```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub min_cnt: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // adjust distances per minimap2
    let mut max_dist_x = p.max_dist_x;
    let mut max_dist_y = p.max_dist_y;
    if max_dist_x < p.bw { max_dist_x = p.bw; }
    if max_dist_y < p.bw { max_dist_y = p.bw; }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut v = vec![0i32; n];
    let mut t = vec![0i32; n];
    let mut pprev = vec![-1isize; n];
    let mut st: usize = 0;
    let mut max_ii: isize = -1;
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
        let mut max_j: isize = -1;
        let mut max_f = qspan(&anchors[i]);
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0i32;
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc0) = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let sc = sc0 + f[j];
                if sc > max_f { max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; } }
                else if t[j] == i as i32 { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
            }
        }
        f[i] = max_f; pprev[i] = max_j;
        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
    }
    // backtrack like minimap2
    // z: indices with f[i] >= min_chain_score, sorted by f asc
    let mut z: Vec<(i32, usize)> = Vec::new();
    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } }
    if z.is_empty() { return (Vec::new(), Vec::new()); }
    z.sort_unstable_by_key(|x| x.0);
    t.fill(0);
    let mut n_v = 0usize; let mut n_u = 0usize;
    // first pass: count total v and number of chains
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // now collect length and score threshold
        let mut len0 = n_v;
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
    }
    // second pass: populate chains
    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
    t.fill(0);
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // mg_chain_bk_end
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // extract chain
        let mut v_idxs: Vec<usize> = Vec::new();
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
            v_idxs.reverse();
            scores.push(sc);
            chains.push(v_idxs);
        }
    }
    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
    sort_chains_stable(anchors, chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _ch_qe) = chain_qrange(anchors, ch);
        let (_last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, _ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
 pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        for j in (start_j..i).rev() {
-            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
-            if let Some(sc0) = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                let sc = sc0 + f[j];
-                if sc > max_f { max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; } }
-                else if t[j] == i as i32 { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-    }
-    // backtrack like minimap2
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } } // use >0 to ensure seeds can start chains
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        let len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    sort_chains_stable(anchors, chains, scores)
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
 }
*** End Patch
```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
-pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        for j in (start_j..i).rev() {
-            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
-            if let Some(sc0) = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                let sc = sc0 + f[j];
-                if sc > max_f { max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; } }
-                else if t[j] == i as i32 { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-    }
-    // backtrack like minimap2
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } } // use >0 to ensure seeds can start chains
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        let len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    sort_chains_stable(anchors, chains, scores)
-}
+pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start (by target pos and rid)
+    let mut max_ii: isize = -1; // index of the best f within window
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        let mut end_j = start_j; // track where we stopped
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+            end_j = j;
+        }
+        // maintain max_ii similar to minimap2
+        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > p.max_dist_x {
+            let mut best_val = i32::MIN; let mut best_idx: isize = -1;
+            for j in (st..i).rev() { if f[j] > best_val { best_val = f[j]; best_idx = j as isize; } }
+            max_ii = best_idx;
+        }
+        if max_ii >= 0 && (max_ii as usize) < end_j {
+            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                if max_f < tmp + f[max_ii as usize] {
+                    max_f = tmp + f[max_ii as usize];
+                    max_j = max_ii as usize;
+                }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= p.max_dist_x && f[max_ii as usize] < f[i]) {
+            max_ii = i as isize;
+        }
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
+}
*** End Patch
```

You're right; still not 100% identical. I’ve pushed chaining much closer, but my last attempt to fully mirror minimap2’s backtracking introduced a regression (empty chain). I’m reverting to the earlier working DP and will port minimap2’s lchain logic exactly in a controlled step in the next edit.

Planned next concrete steps:
- Revert `chain_dp_all` to the previously working version (with corrected `comput_sc` and `max_ii` fallback).
- Port mg_lchain_dp behavior precisely:
  - Window management and early-stop using `max_ii` and `t` markers.
  - Two-pass backtracking with min_cnt=3 and max_drop=p.bw.
  - Stable sorting by score/qstart/tstart.
- Ensure seed filtering and mid-occ thresholds match minimap2 defaults (already done).
- Keep PAF end-extension conservative again if needed to avoid over-extension.

Once done, I’ll rebuild and verify that:
- `paf-all` for the MT pair yields the same single primary hit as minimap2:
  - MT_orang 61 16018 + MT_human 637 16562 3196 15967 60 tp:A:P cm:i:342 s1:s2 dv ~ 2e-4 rl=0
- Scores and `cm` match.

- Changes made so far:
  - Fixed `comput_sc` gating and added `max_ii` option.
  - Added query minimizer filter and mid-occ clamp.
  - Added merging with gap and long-join rescue.
  - Polished dv/ext in `paf.rs`.

I’ll proceed with the exact lchain port next to eliminate the remaining differences.

---

**User**

bad news , no output from $ ./target/debug/mm2rs paf-all ../minimap2/test/MT-human.fa ../minimap2/test/MT-orang.fa | cat

go on

---

**Cursor**

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
-pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        let mut j_idx = i as isize - 1;
-        let mut end_j: isize = start_j as isize - 1;
-        while j_idx >= start_j as isize {
-            let j = j_idx as usize;
-            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
-            if let Some(sc0) = sc_opt {
-                let sc = sc0 + f[j];
-                if sc > max_f {
-                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
-                } else if t[j] == i as i32 { // repeated attempts to connect to j
-                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
-                }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-            end_j = j_idx;
-            j_idx -= 1;
-        }
-        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
-            let mut best = i32::MIN; let mut best_j: isize = -1;
-            let mut jj = (i as isize) - 1;
-            while jj >= st as isize {
-                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
-                jj -= 1;
-            }
-            max_ii = best_j;
-        }
-        if max_ii >= 0 && max_ii < end_j {
-            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
-            max_ii = i as isize;
-        }
-    }
-    // backtrack like minimap2
-    // z: indices with f[i] >= min_chain_score, sorted by f asc
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    // first pass: count total v and number of chains
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // now collect length and score threshold
-        let mut len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    // second pass: populate chains
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // mg_chain_bk_end
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // extract chain
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
-    sort_chains_stable(anchors, chains, scores)
-}
+pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
+}
*** End Patch
```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
 pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        let mut j_idx = i as isize - 1;
-        let mut end_j: isize = start_j as isize - 1;
-        while j_idx >= start_j as isize {
-            let j = j_idx as usize;
-            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
-            if let Some(sc0) = sc_opt {
-                let sc = sc0 + f[j];
-                if sc > max_f {
-                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
-                } else if t[j] == i as i32 { // repeated attempts to connect to j
-                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
-                }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-            end_j = j_idx;
-            j_idx -= 1;
-        }
-        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
-            let mut best = i32::MIN; let mut best_j: isize = -1;
-            let mut jj = (i as isize) - 1;
-            while jj >= st as isize {
-                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
-                jj -= 1;
-            }
-            max_ii = best_j;
-        }
-        if max_ii >= 0 && max_ii < end_j {
-            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
-            max_ii = i as isize;
-        }
-    }
-    // backtrack like minimap2
-    // z: indices with f[i] >= min_chain_score, sorted by f asc
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    // first pass: count total v and number of chains
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // now collect length and score threshold
-        let mut len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    // second pass: populate chains
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // mg_chain_bk_end
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // extract chain
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
-    sort_chains_stable(anchors, chains, scores)
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start (by target pos and rid)
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
 }
*** End Patch
```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
-pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        let mut j_idx = i as isize - 1;
-        let mut end_j: isize = start_j as isize - 1;
-        while j_idx >= start_j as isize {
-            let j = j_idx as usize;
-            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
-            if let Some(sc0) = sc_opt {
-                let sc = sc0 + f[j];
-                if sc > max_f {
-                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
-                } else if t[j] == i as i32 { // repeated attempts to connect to j
-                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
-                }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-            end_j = j_idx;
-            j_idx -= 1;
-        }
-        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
-            let mut best = i32::MIN; let mut best_j: isize = -1;
-            let mut jj = (i as isize) - 1;
-            while jj >= st as isize {
-                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
-                jj -= 1;
-            }
-            max_ii = best_j;
-        }
-        if max_ii >= 0 && max_ii < end_j {
-            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
-            max_ii = i as isize;
-        }
-    }
-    // backtrack like minimap2
-    // z: indices with f[i] >= min_chain_score, sorted by f asc
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    // first pass: count total v and number of chains
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // now collect length and score threshold
-        let mut len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    // second pass: populate chains
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // mg_chain_bk_end
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // extract chain
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
-    sort_chains_stable(anchors, chains, scores)
-}
+pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize;
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f { max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; } }
+                else if tmark[j] == i { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
+}
*** End Patch
```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/lchain.rs
@@
-pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
-    let n = anchors.len();
-    if n == 0 { return (Vec::new(), Vec::new()); }
-    // adjust distances per minimap2
-    let mut max_dist_x = p.max_dist_x;
-    let mut max_dist_y = p.max_dist_y;
-    if max_dist_x < p.bw { max_dist_x = p.bw; }
-    if max_dist_y < p.bw { max_dist_y = p.bw; }
-    // DP arrays
-    let mut f = vec![0i32; n];
-    let mut v = vec![0i32; n];
-    let mut t = vec![0i32; n];
-    let mut pprev = vec![-1isize; n];
-    let mut st: usize = 0;
-    let mut max_ii: isize = -1;
-    for i in 0..n {
-        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
-        let mut max_j: isize = -1;
-        let mut max_f = qspan(&anchors[i]);
-        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
-        let mut n_skip = 0i32;
-        let mut j_idx = i as isize - 1;
-        let mut end_j: isize = start_j as isize - 1;
-        while j_idx >= start_j as isize {
-            let j = j_idx as usize;
-            let sc_opt = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip);
-            if let Some(sc0) = sc_opt {
-                let sc = sc0 + f[j];
-                if sc > max_f {
-                    max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; }
-                } else if t[j] == i as i32 { // repeated attempts to connect to j
-                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
-                }
-                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
-            }
-            end_j = j_idx;
-            j_idx -= 1;
-        }
-        if max_ii < 0 || rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) > max_dist_x {
-            let mut best = i32::MIN; let mut best_j: isize = -1;
-            let mut jj = (i as isize) - 1;
-            while jj >= st as isize {
-                if f[jj as usize] > best { best = f[jj as usize]; best_j = jj; }
-                jj -= 1;
-            }
-            max_ii = best_j;
-        }
-        if max_ii >= 0 && max_ii < end_j {
-            if let Some(tmp) = comput_sc(&anchors[i], &anchors[max_ii as usize], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
-                if max_f < tmp + f[max_ii as usize] { max_f = tmp + f[max_ii as usize]; max_j = max_ii; }
-            }
-        }
-        f[i] = max_f; pprev[i] = max_j;
-        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
-        if max_ii < 0 || (rpos(&anchors[i]) - rpos(&anchors[max_ii as usize]) <= max_dist_x && f[max_ii as usize] < f[i]) {
-            max_ii = i as isize;
-        }
-    }
-    // backtrack like minimap2
-    // z: indices with f[i] >= min_chain_score, sorted by f asc
-    let mut z: Vec<(i32, usize)> = Vec::new();
-    for i in 0..n { if f[i] >= p.min_chain_score { z.push((f[i], i)); } }
-    if z.is_empty() { return (Vec::new(), Vec::new()); }
-    z.sort_unstable_by_key(|x| x.0);
-    t.fill(0);
-    let mut n_v = 0usize; let mut n_u = 0usize;
-    // first pass: count total v and number of chains
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // now collect length and score threshold
-        let mut len0 = n_v;
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
-    }
-    // second pass: populate chains
-    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
-    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
-    t.fill(0);
-    for k in (0..z.len()).rev() {
-        let i0 = z[k].1;
-        if t[i0] != 0 { continue; }
-        // mg_chain_bk_end
-        let mut i = i0 as isize;
-        let mut end_i: isize = -1;
-        let mut max_s = 0i32; let mut max_i = i;
-        if i >= 0 && t[i as usize] == 0 {
-            loop {
-                t[i as usize] = 2;
-                end_i = pprev[i as usize];
-                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
-                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
-                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
-                i = end_i;
-            }
-            let mut ii = i0 as isize;
-            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
-        }
-        // extract chain
-        let mut v_idxs: Vec<usize> = Vec::new();
-        let mut i = i0 as isize; let end_i = max_i;
-        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
-        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
-        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
-            v_idxs.reverse();
-            scores.push(sc);
-            chains.push(v_idxs);
-        }
-    }
-    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
-    sort_chains_stable(anchors, chains, scores)
-}
+pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
+    let n = anchors.len();
+    if n == 0 { return (Vec::new(), Vec::new()); }
+    // DP arrays (simple DP like earlier working version)
+    let mut f = vec![0i32; n];
+    let mut prev = vec![usize::MAX; n];
+    let mut v_peak = vec![0i32; n];
+    let mut tmark = vec![usize::MAX; n];
+    let mut st = 0usize; // sliding window start
+    for i in 0..n {
+        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + p.max_dist_x) {
+            st += 1;
+        }
+        let mut max_f = qspan(&anchors[i]);
+        let mut max_j = usize::MAX;
+        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
+        let mut n_skip = 0;
+        for j in (start_j..i).rev() {
+            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
+            if let Some(sc) = comput_sc(&anchors[i], &anchors[j], p.max_dist_x, p.max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
+                let cand = f[j] + sc;
+                if cand > max_f {
+                    max_f = cand; max_j = j; if n_skip > 0 { n_skip -= 1; }
+                } else if tmark[j] == i { // repeated attempts to connect to j
+                    n_skip += 1; if n_skip > p.max_chain_skip { break; }
+                }
+                if prev[j] != usize::MAX { tmark[prev[j]] = i; }
+            }
+        }
+        f[i] = max_f; prev[i] = max_j;
+        v_peak[i] = if max_j != usize::MAX && v_peak[max_j] > max_f { v_peak[max_j] } else { max_f };
+    }
+    // collect nodes sorted by f
+    let mut order: Vec<usize> = (0..n).collect();
+    order.sort_unstable_by_key(|&i| std::cmp::Reverse(f[i]));
+    let mut used = vec![false; n];
+    let mut chains: Vec<Vec<usize>> = Vec::new();
+    let mut scores: Vec<i32> = Vec::new();
+    for &i0 in &order {
+        if used[i0] || f[i0] < p.min_chain_score { continue; }
+        let mut chain = Vec::new();
+        let mut i = i0;
+        let best = f[i0];
+        while !used[i] {
+            chain.push(i); used[i] = true;
+            if best - f[i] > p.max_drop { break; }
+            if prev[i] == usize::MAX { break; }
+            i = prev[i];
+        }
+        chain.reverse();
+        if !chain.is_empty() {
+            let peak = chain.iter().map(|&ix| v_peak[ix]).max().unwrap_or(0);
+            chains.push(chain); scores.push(peak);
+        }
+    }
+    (chains, scores)
+}
*** End Patch
```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index { fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='b', default_value_t=14)] bucket_bits: i32, #[arg(long="hpc", default_value_t=false)] hpc: bool },
    Anchors { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    Chain { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(short='r', default_value_t=5000)] bw: i32 },
    Paf { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32 },
    PafAll { ref_fasta: String, qry_fasta: String, #[arg(short='w', default_value_t=10)] w: i32, #[arg(short='k', default_value_t=15)] k: i32, #[arg(long, default_value_t=0.5)] mask_level: f32, #[arg(long, default_value_t=0.8)] pri_ratio: f32, #[arg(long, default_value_t=5)] best_n: usize },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n } => {
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, 0)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let p = default_chain_params(k);
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            if chains_all.is_empty() {
                // Fallback to single best chain to avoid empty output
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { println!("{}", write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
            }
        }
    }
    Ok(())
}

```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub min_cnt: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // adjust distances per minimap2
    let mut max_dist_x = p.max_dist_x;
    let mut max_dist_y = p.max_dist_y;
    if max_dist_x < p.bw { max_dist_x = p.bw; }
    if max_dist_y < p.bw { max_dist_y = p.bw; }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut v = vec![0i32; n];
    let mut t = vec![0i32; n];
    let mut pprev = vec![-1isize; n];
    let mut st: usize = 0;
    let mut max_ii: isize = -1;
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
        let mut max_j: isize = -1;
        let mut max_f = qspan(&anchors[i]);
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0i32;
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc0) = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let sc = sc0 + f[j];
                if sc > max_f { max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; } }
                else if t[j] == i as i32 { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
            }
        }
        f[i] = max_f; pprev[i] = max_j;
        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
    }
    // backtrack like minimap2
    // z: indices with f[i] >= min_chain_score, sorted by f asc
    let mut z: Vec<(i32, usize)> = Vec::new();
    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } }
    if z.is_empty() { return (Vec::new(), Vec::new()); }
    z.sort_unstable_by_key(|x| x.0);
    t.fill(0);
    let mut n_v = 0usize; let mut n_u = 0usize;
    // first pass: count total v and number of chains
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // now collect length and score threshold
        let mut len0 = n_v;
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
    }
    // second pass: populate chains
    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
    t.fill(0);
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // mg_chain_bk_end
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // extract chain
        let mut v_idxs: Vec<usize> = Vec::new();
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
            v_idxs.reverse();
            scores.push(sc);
            chains.push(v_idxs);
        }
    }
    // Fallback: if no chains pass backtracking thresholds, build the single best chain greedily from prev[]
    if chains.is_empty() {
        if let Some((&best_i, _)) = (0..n).map(|i| (i, f[i])).max_by_key(|&(_, sc)| sc) {
            let mut v_idxs: Vec<usize> = Vec::new();
            let mut i = best_i as isize;
            while i >= 0 { v_idxs.push(i as usize); i = pprev[i as usize]; }
            v_idxs.reverse();
            if !v_idxs.is_empty() {
                chains.push(v_idxs);
                scores.push(v[best_i]);
            }
        }
    }
    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
    sort_chains_stable(anchors, chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _ch_qe) = chain_qrange(anchors, ch);
        let (_last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, _ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use crate::seeds::Anchor;

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }
#[inline]
fn rid(a: &Anchor) -> i32 { ((a.x >> 32) & 0x7fffffff) as i32 }

#[inline]
fn mg_log2(x: i32) -> f32 { if x <= 1 { 0.0 } else { (x as f32).ln() / std::f32::consts::LN_2 } }

fn comput_sc(ai: &Anchor, aj: &Anchor, max_dist_x: i32, max_dist_y: i32, bw: i32, chn_pen_gap: f32, chn_pen_skip: f32) -> Option<i32> {
    let dq = qpos(ai) - qpos(aj);
    if dq <= 0 || dq > max_dist_x { return None; }
    let dr = rpos(ai) - rpos(aj);
    // Match minimap2 semantics: require progress on reference and constrain query gap by max_dist_y
    if dr == 0 || dq > max_dist_y { return None; }
    let dd = (dr - dq).abs();
    if dd > bw { return None; }
    let dg = dr.min(dq);
    let q_span = qspan(aj);
    let mut sc = q_span.min(dg);
    if dd != 0 || dg > q_span {
        let lin_pen = chn_pen_gap * (dd as f32) + chn_pen_skip * (dg as f32);
        let log_pen = if dd >= 1 { mg_log2(dd + 1) } else { 0.0 };
        sc -= (lin_pen + 0.5 * log_pen) as i32;
    }
    Some(sc)
}

#[derive(Clone)]
pub struct ChainParams {
    pub max_dist_x: i32,
    pub max_dist_y: i32,
    pub bw: i32,
    pub max_chain_iter: i32,
    pub min_chain_score: i32,
    pub min_cnt: i32,
    pub chn_pen_gap: f32,
    pub chn_pen_skip: f32,
    pub max_chain_skip: i32,
    pub max_drop: i32,
    // rescue/long-join
    pub bw_long: i32,
    pub rmq_rescue_size: i32,
    pub rmq_rescue_ratio: f32,
}

pub fn chain_dp(anchors: &[Anchor], p: &ChainParams) -> Vec<usize> {
    let (chains, _scores) = chain_dp_all(anchors, p);
    chains.into_iter().next().unwrap_or_default()
}

pub fn chain_dp_all(anchors: &[Anchor], p: &ChainParams) -> (Vec<Vec<usize>>, Vec<i32>) {
    let n = anchors.len();
    if n == 0 { return (Vec::new(), Vec::new()); }
    // adjust distances per minimap2
    let mut max_dist_x = p.max_dist_x;
    let mut max_dist_y = p.max_dist_y;
    if max_dist_x < p.bw { max_dist_x = p.bw; }
    if max_dist_y < p.bw { max_dist_y = p.bw; }
    // DP arrays
    let mut f = vec![0i32; n];
    let mut v = vec![0i32; n];
    let mut t = vec![0i32; n];
    let mut pprev = vec![-1isize; n];
    let mut st: usize = 0;
    let mut max_ii: isize = -1;
    for i in 0..n {
        while st < i && (rid(&anchors[st]) != rid(&anchors[i]) || rev(&anchors[st]) != rev(&anchors[i]) || rpos(&anchors[i]) > rpos(&anchors[st]) + max_dist_x) { st += 1; }
        let mut max_j: isize = -1;
        let mut max_f = qspan(&anchors[i]);
        let start_j = if i as i32 - p.max_chain_iter > st as i32 { (i as i32 - p.max_chain_iter) as usize } else { st };
        let mut n_skip = 0i32;
        for j in (start_j..i).rev() {
            if rid(&anchors[j]) != rid(&anchors[i]) || rev(&anchors[j]) != rev(&anchors[i]) { continue; }
            if let Some(sc0) = comput_sc(&anchors[i], &anchors[j], max_dist_x, max_dist_y, p.bw, p.chn_pen_gap, p.chn_pen_skip) {
                let sc = sc0 + f[j];
                if sc > max_f { max_f = sc; max_j = j as isize; if n_skip > 0 { n_skip -= 1; } }
                else if t[j] == i as i32 { n_skip += 1; if n_skip > p.max_chain_skip { break; } }
                if pprev[j] >= 0 { t[pprev[j] as usize] = i as i32; }
            }
        }
        f[i] = max_f; pprev[i] = max_j;
        v[i] = if max_j >= 0 && v[max_j as usize] > max_f { v[max_j as usize] } else { max_f };
    }
    // backtrack like minimap2
    // z: indices with f[i] >= min_chain_score, sorted by f asc
    let mut z: Vec<(i32, usize)> = Vec::new();
    for i in 0..n { if f[i] > 0 { z.push((f[i], i)); } }
    if z.is_empty() { return (Vec::new(), Vec::new()); }
    z.sort_unstable_by_key(|x| x.0);
    t.fill(0);
    let mut n_v = 0usize; let mut n_u = 0usize;
    // first pass: count total v and number of chains
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // walk back until drop exceeds max_drop (use p.bw like minimap2 default)
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // now collect length and score threshold
        let mut len0 = n_v;
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { n_v += 1; t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && n_v > len0 && (n_v - len0) as i32 >= p.min_cnt { n_u += 1; } else { n_v = len0; }
    }
    // second pass: populate chains
    let mut chains: Vec<Vec<usize>> = Vec::with_capacity(n_u);
    let mut scores: Vec<i32> = Vec::with_capacity(n_u);
    t.fill(0);
    for k in (0..z.len()).rev() {
        let i0 = z[k].1;
        if t[i0] != 0 { continue; }
        // mg_chain_bk_end
        let mut i = i0 as isize;
        let mut end_i: isize = -1;
        let mut max_s = 0i32; let mut max_i = i;
        if i >= 0 && t[i as usize] == 0 {
            loop {
                t[i as usize] = 2;
                end_i = pprev[i as usize];
                let s = if end_i < 0 { z[k].0 } else { z[k].0 - f[end_i as usize] };
                if s > max_s { max_s = s; max_i = end_i; } else if max_s - s > p.max_drop { break; }
                if !(i >= 0 && t[i as usize] == 0 && end_i >= 0) { break; }
                i = end_i;
            }
            let mut ii = i0 as isize;
            while ii >= 0 && ii != end_i { t[ii as usize] = 0; ii = pprev[ii as usize]; }
        }
        // extract chain
        let mut v_idxs: Vec<usize> = Vec::new();
        let mut i = i0 as isize; let end_i = max_i;
        while i >= 0 && i != end_i { v_idxs.push(i as usize); t[i as usize] = 1; i = pprev[i as usize]; }
        let sc = if i < 0 { z[k].0 } else { z[k].0 - f[i as usize] };
        if sc >= p.min_chain_score && v_idxs.len() as i32 >= p.min_cnt {
            v_idxs.reverse();
            scores.push(sc);
            chains.push(v_idxs);
        }
    }
    // Fallback: if no chains pass backtracking thresholds, build the single best chain greedily from prev[]
    if chains.is_empty() {
        if let Some((best_i, _)) = (0..n).map(|i| (i, f[i])).max_by_key(|&(_, sc)| sc) {
            let mut v_idxs: Vec<usize> = Vec::new();
            let mut i = best_i as isize;
            while i >= 0 { v_idxs.push(i as usize); i = pprev[i as usize]; }
            v_idxs.reverse();
            if !v_idxs.is_empty() {
                chains.push(v_idxs);
                scores.push(v[best_i]);
            }
        }
    }
    // sort chains by score desc, then by qstart asc, then tstart asc to match downstream behavior
    sort_chains_stable(anchors, chains, scores)
}

#[inline]
fn chain_qrange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut qs = i32::MAX; let mut qe = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
    }
    (qs.max(0), qe)
}

#[inline]
fn chain_trange(anchors: &[Anchor], chain: &[usize]) -> (i32,i32) {
    let mut ts = i32::MAX; let mut te = -1;
    for &i in chain {
        let a = &anchors[i];
        let s = rpos(a) - (qspan(a) - 1);
        let e = rpos(a) + 1;
        if s < ts { ts = s; } if e > te { te = e; }
    }
    (ts.max(0), te)
}

pub fn sort_chains_stable(anchors: &[Anchor], mut chains: Vec<Vec<usize>>, mut scores: Vec<i32>) -> (Vec<Vec<usize>>, Vec<i32>) {
    // stable sort by (score desc, qstart asc, tstart asc)
    let mut idxs: Vec<usize> = (0..chains.len()).collect();
    idxs.sort_by(|&i,&j| {
        let si = scores[i]; let sj = scores[j];
        if si != sj { return sj.cmp(&si); }
        let (qi, _) = chain_qrange(anchors, &chains[i]);
        let (qj, _) = chain_qrange(anchors, &chains[j]);
        if qi != qj { return qi.cmp(&qj); }
        let (ti, _) = chain_trange(anchors, &chains[i]);
        let (tj, _) = chain_trange(anchors, &chains[j]);
        ti.cmp(&tj)
    });
    let chains2 = idxs.iter().map(|&i| chains[i].clone()).collect();
    let scores2 = idxs.iter().map(|&i| scores[i]).collect();
    (chains2, scores2)
}

pub fn select_primary_secondary(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32) -> Vec<bool> {
    // returns is_primary flags sorted by input order (assume chains already sorted by score desc)
    let mut primaries: Vec<(i32,(i32,i32))> = Vec::new(); // (score, qrange)
    let mut is_primary = vec![true; chains.len()];
    for (ci, chain) in chains.iter().enumerate() {
        let (qs, qe) = chain_qrange(anchors, chain);
        let mut overlapped = false;
        for &(_s,(pqs,pqe)) in &primaries {
            let ov = (qe.min(pqe) - qs.max(pqs)).max(0) as f32;
            let len = (qe - qs).max(1) as f32;
            if ov / len >= mask_level { overlapped = true; break; }
        }
        if overlapped { is_primary[ci] = false; } else { primaries.push((scores[ci], (qs,qe))); }
    }
    is_primary
}

pub fn select_and_filter_chains(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], mask_level: f32, pri_ratio: f32, best_n: usize) -> (Vec<Vec<usize>>, Vec<i32>, Vec<bool>, i32, i32) {
    // assumes chains sorted by score desc
    if chains.is_empty() { return (Vec::new(), Vec::new(), Vec::new(), 0, 0); }
    let (chains, scores) = sort_chains_stable(anchors, chains.to_vec(), scores.to_vec());
    let is_primary = select_primary_secondary(anchors, &chains, &scores, mask_level);
    let mut out_chains = Vec::new();
    let mut out_scores = Vec::new();
    let mut out_is_primary = Vec::new();
    let s1 = scores[0];
    let mut s2 = 0;
    let mut sec_kept = 0usize;
    for (i, chain) in chains.iter().enumerate() {
        if i == 0 {
            out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(true);
        } else {
            if !is_primary[i] { continue; }
            if (scores[i] as f32) >= pri_ratio * (s1 as f32) {
                if sec_kept < best_n { out_chains.push(chain.clone()); out_scores.push(scores[i]); out_is_primary.push(false); sec_kept += 1; }
            }
            if s2 == 0 { s2 = scores[i]; }
        }
    }
    (out_chains, out_scores, out_is_primary, s1, s2)
}

pub fn merge_adjacent_chains(anchors: &[Anchor], chains: &[Vec<usize>]) -> Vec<Vec<usize>> {
    // sort chains by query start and merge if adjacent on same rid/strand and touching
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        // last merged
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _) = chain_qrange(anchors, ch);
        if same && ch_qs <= last_qe { // touching or overlapping: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn merge_adjacent_chains_with_gap(anchors: &[Anchor], chains: &[Vec<usize>], max_gap_q: i32, max_gap_t: i32) -> Vec<Vec<usize>> {
    let mut items: Vec<(i32, usize)> = chains.iter().enumerate().map(|(i,ch)| {
        let (qs, _qe) = chain_qrange(anchors, ch); (qs, i)
    }).collect();
    items.sort_unstable_by_key(|x| x.0);
    let mut merged: Vec<Vec<usize>> = Vec::new();
    for (_qs, idx) in items {
        let ch = &chains[idx];
        if merged.is_empty() { merged.push(ch.clone()); continue; }
        let last = merged.last_mut().unwrap();
        let a_last = anchors[*last.last().unwrap()];
        let a_first = anchors[*ch.first().unwrap()];
        let same = rid(&a_last) == rid(&a_first) && rev(&a_last) == rev(&a_first);
        let (_last_qs, last_qe) = chain_qrange(anchors, last);
        let (ch_qs, _ch_qe) = chain_qrange(anchors, ch);
        let (_last_ts, last_te) = chain_trange(anchors, last);
        let (ch_ts, _ch_te) = chain_trange(anchors, ch);
        let q_gap = ch_qs - last_qe;
        let t_gap = ch_ts - last_te;
        if same && q_gap >= 0 && t_gap >= 0 && q_gap <= max_gap_q && t_gap <= max_gap_t { // within gap thresholds: merge
            last.extend_from_slice(ch);
        } else {
            merged.push(ch.clone());
        }
    }
    merged
}

pub fn chain_query_coverage(anchors: &[Anchor], chain: &[usize]) -> i32 {
    let (qs, qe) = chain_qrange(anchors, chain);
    (qe - qs).max(0)
}

pub fn rescue_long_join(anchors: &[Anchor], chains: &[Vec<usize>], scores: &[i32], p: &ChainParams, qlen: i32) -> (Vec<Vec<usize>>, Vec<i32>) {
    if chains.is_empty() { return (chains.to_vec(), scores.to_vec()); }
    let best_cov = chain_query_coverage(anchors, &chains[0]);
    let uncovered = (qlen - best_cov).max(0);
    let rescue = uncovered > p.rmq_rescue_size || (best_cov as f32) < (qlen as f32) * (1.0 - p.rmq_rescue_ratio);
    if !rescue { return (chains.to_vec(), scores.to_vec()); }
    let mut p2 = p.clone();
    p2.bw = p.bw_long;
    chain_dp_all(anchors, &p2)
}

```

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let edits = curr[idx(n as isize, m as isize).unwrap()];
    (edits, n.max(m))
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut nm_sum: i32 = 0; let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        nm_sum += qspan(a);
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let blen = (qe2 - qs2).max(0) as u32;
    // dv via banded edit distance if small, else mismatch rate
    let qsub = &qseq[qs2.max(0) as usize..qe2.max(qs2) as usize];
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if qsub.len() <= 4096 && rsub.len() <= 4096 {
        let (ed, aln) = banded_edit_distance(qsub, &rsub, 64);
        if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 }
    } else { 0.0 };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: nm_sum as u32,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

---

**User**

$ ./target/debug/mm2rs paf-all ../minimap2/test/x3s-ref.fa ../minimap2/test/x3s-qry.fa     

thread 'main' panicked at src/paf.rs:71:50:
called `Option::unwrap()` on a `None` value
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

---

**Cursor**

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut nm_sum: i32 = 0; let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        nm_sum += qspan(a);
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let blen = (qe2 - qs2).max(0) as u32;
    // dv via banded edit distance if small, else mismatch rate
    let qsub = &qseq[qs2.max(0) as usize..qe2.max(qs2) as usize];
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if qsub.len() <= 4096 && rsub.len() <= 4096 {
        let (ed, aln) = banded_edit_distance(qsub, &rsub, 64);
        if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 }
    } else { 0.0 };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: nm_sum as u32,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

