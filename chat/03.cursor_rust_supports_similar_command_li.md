# Rust supports similar command line habits
_Exported on 8/8/2025 at 15:28:02 GMT+8 from Cursor (1.4.2)_

---

**User**

@main.rs @main.c  Rust支持相同命令行习惯

---

**Cursor**

I'll update the Rust CLI to accept minimap2-like short options for the mapping flow, including -M, -p, -N, -r, and -H in the `PafAll` command, and wire these into the existing logic. Then I'll build to verify everything compiles.

I’m going to add minimap2-style short options to the Rust CLI:
- Add `-H` to enable HPC for all commands that build an index.
- Add `-M`, `-p`, `-N` to `PafAll`.
- Add `-r` (NUM[,NUM]) to `Paf` and `PafAll` to set chaining and long-join bandwidths.
Then I’ll build the project to ensure it compiles.

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Paf {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        // -r NUM[,NUM] chaining/alignment bandwidth and long-join bandwidth
        #[arg(short = 'r')]
        r: Option<String>,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    PafAll {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32,
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32,
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize,
        // -r NUM[,NUM] chaining/alignment bandwidth and long-join bandwidth
        #[arg(short = 'r')]
        r: Option<String>,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Paf{ ref_fasta, qry_fasta, w, k, r, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let chain = chain_dp(&anchors, &p);
            if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) {
                print!("{}\n", write_paf(&rec));
            }
        }
        Commands::PafAll{ ref_fasta, qry_fasta, w, k, mask_level, pri_ratio, best_n, r, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            // Seed mid-occ filtering (similar to minimap2 mm_idx_cal_max_occ with 2e-4) and clamp to >=10
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            if chains_all.is_empty() {
                // Fallback to single best chain to avoid empty output
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { println!("{}", write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                // Merge adjacent chains if gaps are within thresholds, similar to long-join behavior
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                for line in write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q) { println!("{}", line); }
            }
        }
    }
    Ok(())
}

```

Built new short options in the Rust CLI and attempted a build; now I'll build inside the `mm2rs` crate.

Added minimap2-like CLI flags to Rust `mm2rs` and built.

- Paf/PafAll: support `-r NUM[,NUM]` to set `bw` and `bw_long`.
- PafAll: added `-M` (mask_level), `-p` (pri_ratio), `-N` (best_n).
- All index-building paths (`Index`, `Anchors`, `Chain`, `Paf`, `PafAll`) accept `-H/--hpc` to enable HPC.
- Build succeeded; only warnings in unrelated files.

Examples:
- PAF: `mm2rs paf ref.fa qry.fa -w 10 -k 15 -r 500,20000 -H`
- PAF all: `mm2rs paf-all ref.fa qry.fa -w 10 -k 15 -M 0.5 -p 0.8 -N 5 -r 500,20000 -H`

Status: Implemented edits in `mm2rs/src/main.rs` and verified compilation.

---

**User**

replace paf/paf-all command with align and support mapping , alignemnt ,input output , preset option, $ ../minimap2/minimap2 
Usage: minimap2 [options] <target.fa>|<target.idx> [query.fa] [...]
Options:
  Indexing:
    -H           use homopolymer-compressed k-mer (preferrable for PacBio)
    -k INT       k-mer size (no larger than 28) [15]
    -w INT       minimizer window size [10]
    -I NUM       split index for every ~NUM input bases [8G]
    -d FILE      dump index to FILE []
  Mapping:
    -f FLOAT     filter out top FLOAT fraction of repetitive minimizers [0.0002]
    -g NUM       stop chain enlongation if there are no minimizers in INT-bp [5000]
    -G NUM       max intron length (effective with -xsplice; changing -r) [200k]
    -F NUM       max fragment length (effective with -xsr or in the fragment mode) [800]
    -r NUM[,NUM] chaining/alignment bandwidth and long-join bandwidth [500,20000]
    -n INT       minimal number of minimizers on a chain [3]
    -m INT       minimal chaining score (matching bases minus log gap penalty) [40]
    -X           skip self and dual mappings (for the all-vs-all mode)
    -p FLOAT     min secondary-to-primary score ratio [0.8]
    -N INT       retain at most INT secondary alignments [5]
  Alignment:
    -A INT       matching score [2]
    -B INT       mismatch penalty (larger value for lower divergence) [4]
    -O INT[,INT] gap open penalty [4,24]
    -E INT[,INT] gap extension penalty; a k-long gap costs min{O1+k*E1,O2+k*E2} [2,1]
    -z INT[,INT] Z-drop score and inversion Z-drop score [400,200]
    -s INT       minimal peak DP alignment score [80]
    -u CHAR      how to find GT-AG. f:transcript strand, b:both strands, n:don't match GT-AG [n]
    -J INT       splice mode. 0: original minimap2 model; 1: miniprot model [1]
    -j FILE      junctions in BED12 to extend *short* RNA-seq alignment []
  Input/Output:
    -a           output in the SAM format (PAF by default)
    -o FILE      output alignments to FILE [stdout]
    -L           write CIGAR with >65535 ops at the CG tag
    -R STR       SAM read group line in a format like '@RG\tID:foo\tSM:bar' []
    -c           output CIGAR in PAF
    --cs[=STR]   output the cs tag; STR is 'short' (if absent) or 'long' [none]
    --ds         output the ds tag, which is an extension to cs
    --MD         output the MD tag
    --eqx        write =/X CIGAR operators
    -Y           use soft clipping for supplementary alignments
    -y           copy FASTA/Q comments to output SAM
    -t INT       number of threads [3]
    -K NUM       minibatch size for mapping [500M]
    --version    show version number
  Preset:
    -x STR       preset (always applied before other options; see minimap2.1 for details) []
                 - lr:hq - accurate long reads (error rate <1%) against a reference genome
                 - splice/splice:hq - spliced alignment for long reads/accurate long reads
                 - splice:sr - spliced alignment for short RNA-seq reads
                 - asm5/asm10/asm20 - asm-to-ref mapping, for ~0.1/1/5% sequence divergence
                 - sr - short reads against a reference
                 - map-pb/map-hifi/map-ont/map-iclr - CLR/HiFi/Nanopore/ICLR vs reference mapping
                 - ava-pb/ava-ont - PacBio CLR/Nanopore read overlap

See `man ./minimap2.1' for detailed description of these and other advanced command-line options. 

---

**Cursor**

I'll scan relevant Rust files to identify how to wire mapping parameters (-f, -g, -r, -n, -m, -p, -N), alignment-related toggles (output format flags), and preset handling into the new unified `align` command. Then I'll implement the CLI changes and compile.

I’m going to replace the PAF commands with a unified `align` command that accepts minimap2-style flags (-f, -g, -r, -n, -m, -M, -p, -N, -H, -x, -o, -a), wire them into the existing chaining and selection logic, and implement basic output file handling. Then I’ll compile.

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

Implemented a unified align command with minimap2-style flags and removed PAF/PafAll.

- New command: `align`
  - Indexing: `-w`, `-k`, `-H/--hpc`
  - Mapping: `-f`, `-g`, `-r NUM[,NUM]`, `-n`, `-m`, `-M`, `-p`, `-N`, `-x`
  - I/O: `-o FILE` (or `-`), `-a` is parsed but currently outputs PAF only
- Preset hook: minimal `-x` support (`map-ont`, `map-hifi`/`lr:hq`, `sr`)
- Wires options into chaining, rescue, merging, and selection; outputs PAF lines to stdout or file.

Examples:
- Basic: `mm2rs align ref.fa qry.fa -w 10 -k 15`
- With bandwidths: `mm2rs align ref.fa qry.fa -r 500,20000 -g 5000`
- With selection params: `mm2rs align ref.fa qry.fa -M 0.5 -p 0.8 -N 5`
- Preset: `mm2rs align ref.fa qry.fa -x map-ont`
- Output to file: `mm2rs align ref.fa qry.fa -o out.paf`

Build: compiled successfully (warnings only).

- Edited `mm2rs/src/main.rs`:
  - Replaced `Paf`/`PafAll` with `Align`
  - Added preset function
  - Added file output handling
  - Applied mapping params to `ChainParams` and filters

