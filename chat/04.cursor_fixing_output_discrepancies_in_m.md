# Fixing output discrepancies in mm2rs
_Exported on 8/8/2025 at 15:29:27 GMT+8 from Cursor (1.4.2)_

---

**User**

The mm2rs is Rust implemetation of C version (minimap2), i found the paf output is exact same , find the issue and fix 

$ ../minimap2/minimap2 -v 0 ../minimap2/test/x3s-ref.fa ../minimap2/test/x3s-qry.fa
query   134     3       130     -       ref     388     64      325     127     261     60      tp:A:P  cm:i:21 s1:i:108        s2:i:0  dv:f:0.0031      rl:i:0
(base) 
# xzg @ DESKTOP-AK4KKMM in ~/project/minimap2_rs2/mm2rs [14:07:47] 
$ ./target/release/mm2rs align ../minimap2/test/x3s-ref.fa ../minimap2/test/x3s-qry.fa
query   134     3       130     -       ref     388     64      325     315     127     60      tp:A:P  cm:i:21 s1:i:108        s2:i:0  dv:f:1.0000      rl:i:0

---

**Cursor**

I'll scan the Rust code to locate where PAF records are generated and how the dv/nmatch/alen fields are computed and printed, then compare it to the C reference to identify the mismatch.

Reading the relevant files to locate the PAF formatting and computation to fix the swapped fields and dv calculation.

Implementing fixes in `mm2rs/src/paf.rs`: correct mlen/blen fields, handle reverse-complement for '-' strand when computing dv, and use an adaptive band for edit distance with a mismatch-rate fallback. Then I’ll build and run the example to verify outputs match minimap2.

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv via adaptive-band edit distance (on the proper strand); fallback to mismatch rate if necessary
    let mut qsub = qseq[qs2.max(0) as usize..qe2.max(qs2) as usize].to_vec();
    if strand == '-' { qsub = revcomp(&qsub); }
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if !qsub.is_empty() && !rsub.is_empty() {
        let len_q = qsub.len();
        let len_r = rsub.len();
        let band = (len_q as i32 - len_r as i32).abs() as usize + 64; // ensure the main diagonal is inside band
        let (ed, aln) = banded_edit_distance(&qsub, &rsub, band.min(8192));
        let mut d = if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 };
        if d >= 1.0 { d = estimate_dv_by_mismatch(&qsub, &rsub); }
        d
    } else { 0.0 };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

Building the `mm2rs` crate and running the test alignment to verify the PAF differences are corrected.

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv via adaptive-band edit distance (on the proper strand); fallback to mismatch rate if necessary
    let mut qsub = qseq[qs2.max(0) as usize..qe2.max(qs2) as usize].to_vec();
    if strand == '-' { qsub = revcomp(&qsub); }
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if blen > 0 { 1.0f32 - (mlen as f32)/(blen as f32) } else { 0.0 };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::Anchor;
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv via wide-band edit distance (on the proper strand); fallback to mismatch rate if necessary
    let mut qsub = qseq[qs2.max(0) as usize..qe2.max(qs2) as usize].to_vec();
    if strand == '-' { qsub = revcomp(&qsub); }
    let rsub = idx.get_ref_subseq(rid0, ts2.max(0), te2.max(ts2));
    let dv = if !qsub.is_empty() && !rsub.is_empty() {
        let len_q = qsub.len();
        let len_r = rsub.len();
        let band = len_q.max(len_r); // effectively full DP for these lengths
        let (ed, aln) = banded_edit_distance(&qsub, &rsub, band);
        let mut d = if aln > 0 { (ed as f32) / (aln as f32) } else { 0.0 };
        if d > 1.0 { d = estimate_dv_by_mismatch(&qsub, &rsub); }
        d
    } else { 0.0 };
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = (rec.qstart, rec.qend);
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::{Anchor, collect_query_minimizers};
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv estimate following mm_est_err-like logic using query minimizer positions
    let mv = collect_query_minimizers(qseq, idx.w as usize, idx.k as usize);
    let mut mini_pos: Vec<i32> = Vec::with_capacity(mv.len());
    let mut sum_k: u64 = 0;
    for m in &mv { mini_pos.push(((m.rid_pos_strand >> 1) & 0xffffffff) as i32); sum_k += ((m.key_span & 0xff) as u64); }
    let avg_k: f32 = if !mv.is_empty() { (sum_k as f32) / (mv.len() as f32) } else { idx.k as f32 };
    // prepare chain query positions on forward strand
    let qpos_fwd = |a: &Anchor| -> i32 {
        let qp = qpos(a);
        let qs = qspan(a);
        if rev(a) { (qseq.len() as i32) - 1 - (qp + 1 - qs) } else { qp }
    };
    let mut chain_qs_fwd: Vec<i32> = Vec::with_capacity(chain.len());
    if strand == '-' {
        for &i in chain.iter().rev() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    } else {
        for &i in chain.iter() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    }
    // find start index in minimizer list
    let mut dv = 0.0f32;
    if !mini_pos.is_empty() && !chain_qs_fwd.is_empty() {
        // binary search for first equal position
        let first = chain_qs_fwd[0];
        if let Ok(mut st) | Err(st) = mini_pos.binary_search(&first) {
            // move st to the first occurrence if duplicates
            while st > 0 && mini_pos[st-1] == first { st -= 1; }
            let mut j = st;
            let mut k = 1usize;
            let mut en = st;
            let mut n_match = 1i32;
            while j + 1 < mini_pos.len() && k < chain_qs_fwd.len() {
                j += 1;
                if mini_pos[j] == chain_qs_fwd[k] { n_match += 1; en = j as i32; k += 1; }
            }
            let mut n_tot = (en - st as i32 + 1).max(1);
            // edge adjustment like minimap2
            if qs2 > avg_k as i32 && ts2 > avg_k as i32 { n_tot += 1; }
            if (qseq.len() as i32 - qs2) > avg_k as i32 && (tlen as i32 - te2) > avg_k as i32 { n_tot += 1; }
            let frac = (n_match as f32) / (n_tot as f32);
            if frac >= 1.0 { dv = 0.0; }
            else { dv = 1.0 - frac.powf(1.0 / avg_k.max(1.0)); }
        }
    }
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = (rec.qstart, rec.qend);
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::{Anchor, collect_query_minimizers};
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv estimate following mm_est_err-like logic using query minimizer positions
    let mv = collect_query_minimizers(qseq, idx.w as usize, idx.k as usize);
    let mut mini_pos: Vec<i32> = Vec::with_capacity(mv.len());
    let mut sum_k: u64 = 0;
    for m in &mv { mini_pos.push(((m.rid_pos_strand >> 1) & 0xffffffff) as i32); sum_k += ((m.key_span & 0xff) as u64); }
    let avg_k: f32 = if !mv.is_empty() { (sum_k as f32) / (mv.len() as f32) } else { idx.k as f32 };
    // prepare chain query positions on forward strand
    let qpos_fwd = |a: &Anchor| -> i32 {
        let qp = qpos(a);
        let qs = qspan(a);
        if rev(a) { (qseq.len() as i32) - 1 - (qp + 1 - qs) } else { qp }
    };
    let mut chain_qs_fwd: Vec<i32> = Vec::with_capacity(chain.len());
    if strand == '-' {
        for &i in chain.iter().rev() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    } else {
        for &i in chain.iter() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    }
    // find start index in minimizer list
    let mut dv = 0.0f32;
    if !mini_pos.is_empty() && !chain_qs_fwd.is_empty() {
        // binary search for first equal position
        let first = chain_qs_fwd[0];
        let bs = mini_pos.binary_search(&first);
        if bs.is_ok() || bs.is_err() {
            let mut st: usize = match bs { Ok(v)|Err(v) => v };
            // move st to the first occurrence if duplicates
            while st > 0 && mini_pos[st-1] == first { st -= 1; }
            let mut j = st;
            let mut k = 1usize;
            let mut en = st;
            let mut n_match = 1i32;
            while j + 1 < mini_pos.len() && k < chain_qs_fwd.len() {
                j += 1;
                if mini_pos[j] == chain_qs_fwd[k] { n_match += 1; en = j; k += 1; }
            }
            let mut n_tot: i32 = ((en - st) + 1) as i32;
            // edge adjustment like minimap2
            if qs2 > avg_k as i32 && ts2 > avg_k as i32 { n_tot += 1; }
            if (qseq.len() as i32 - qs2) > avg_k as i32 && (tlen as i32 - te2) > avg_k as i32 { n_tot += 1; }
            let frac = (n_match as f32) / (n_tot as f32);
            if frac >= 1.0 { dv = 0.0; }
            else { dv = 1.0 - frac.powf(1.0 / avg_k.max(1.0)); }
        }
    }
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = (rec.qstart, rec.qend);
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

- Found two issues in `mm2rs` PAF:
  - Columns 10/11 were wrong: using chain span as “nmatch” and query span as “alen”. In PAF they are mlen and blen (like minimap2’s `r->mlen`, `r->blen`).
  - `dv:f` was defaulting to 1.0000 and `qs,qe` were flipped on reverse strand (minimap2 does not flip query coords).

- Fixes applied in `mm2rs/src/paf.rs`:
  - Compute and print correct fields: `mlen = qe-qs` (10th), `blen = te-ts` (11th).
  - Don’t flip `qs,qe` for `'-'` strand.
  - Estimate `dv` from minimizers similarly to minimap2’s `mm_est_err` (seed-based divergence), instead of the 1.0 placeholder.

- Verified on your example:
  - Before: `... 315 127 ... dv:f:1.0000 ...`
  - After: `... 127 261 ... dv:f:0.0060 ...` (close to minimap2’s `0.0031`, with exact mlen/blen match)

Commands used:
- Build:
  - `cd /home/xzg/project/minimap2_rs2/mm2rs && cargo build --release`
- Test:
  - `./target/release/mm2rs align ../minimap2/test/x3s-ref.fa ../minimap2/test/x3s-qry.fa`

- If you want `dv` to match even tighter, we can port `mm_est_err` more exactly (including handling per-anchor mapping and boundary adjustments); current result is already very close.

- Edits:
  - `mm2rs/src/paf.rs`: correct mlen/blen columns, stop reversing query coords on `'-'`, add seed-based `dv` estimator.

Summary:
- Fixed PAF columns (now 10=127, 11=261) and corrected `dv` estimation; query coords now match minimap2’s convention.

---

**User**

close is not enough, same is what i want, 

---

**Cursor**

```rust
use crate::seeds::{Anchor, collect_query_minimizers};
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv estimate following mm_est_err logic using query minimizer positions
    let mv = collect_query_minimizers(qseq, idx.w as usize, idx.k as usize);
    let mut mini_pos: Vec<i32> = Vec::with_capacity(mv.len());
    for m in &mv { mini_pos.push(((m.rid_pos_strand >> 1) & 0xffffffff) as i32); }
    let avg_k: f32 = idx.k as f32; // match minimap2 behavior closely
    // prepare chain query positions on forward strand
    let qpos_fwd = |a: &Anchor| -> i32 {
        let qp = qpos(a);
        let qs = qspan(a);
        if rev(a) { (qseq.len() as i32) - 1 - (qp + 1 - qs) } else { qp }
    };
    let mut chain_qs_fwd: Vec<i32> = Vec::with_capacity(chain.len());
    if strand == '-' {
        for &i in chain.iter().rev() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    } else {
        for &i in chain.iter() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    }
    // find start index in minimizer list
    let mut dv = 0.0f32;
    if !mini_pos.is_empty() && !chain_qs_fwd.is_empty() {
        // binary search for first equal position
        let first = chain_qs_fwd[0];
        if let Ok(mut st) = mini_pos.binary_search(&first) {
            // move st to the first occurrence if duplicates
            while st > 0 && mini_pos[st-1] == first { st -= 1; }
            let mut j = st;
            let mut k = 1usize;
            let mut en = st;
            let mut n_match = 1i32;
            while j + 1 < mini_pos.len() && k < chain_qs_fwd.len() {
                j += 1;
                if mini_pos[j] == chain_qs_fwd[k] { n_match += 1; en = j; k += 1; }
            }
            let mut n_tot: i32 = ((en - st) + 1) as i32;
            // edge adjustment like minimap2
            if qs2 > avg_k as i32 && ts2 > avg_k as i32 { n_tot += 1; }
            if (qseq.len() as i32 - qs2) > avg_k as i32 && (tlen as i32 - te2) > avg_k as i32 { n_tot += 1; }
            let frac = (n_match as f32) / (n_tot as f32);
            if frac >= 1.0 { dv = 0.0; }
            else { dv = 1.0 - frac.powf(1.0 / avg_k.max(1.0)); }
        }
    }
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = (rec.qstart, rec.qend);
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::{Anchor, collect_query_minimizers};
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv estimate following mm_est_err logic using query minimizer positions
    let mv = collect_query_minimizers(qseq, idx.w as usize, idx.k as usize);
    let mut mini_pos: Vec<i32> = Vec::with_capacity(mv.len());
    let mut sum_k: u64 = 0;
    for m in &mv { mini_pos.push(((m.rid_pos_strand >> 1) & 0xffffffff) as i32); sum_k += (m.key_span & 0xff) as u64; }
    let avg_k: f32 = if !mv.is_empty() { (sum_k as f32) / (mv.len() as f32) } else { idx.k as f32 };
    // prepare chain query positions on forward strand
    let qpos_fwd = |a: &Anchor| -> i32 {
        let qp = qpos(a);
        let qs = qspan(a);
        if rev(a) { (qseq.len() as i32) - 1 - (qp + 1 - qs) } else { qp }
    };
    let mut chain_qs_fwd: Vec<i32> = Vec::with_capacity(chain.len());
    if strand == '-' {
        for &i in chain.iter().rev() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    } else {
        for &i in chain.iter() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    }
    // find start index in minimizer list
    let mut dv = 0.0f32;
    if !mini_pos.is_empty() && !chain_qs_fwd.is_empty() {
        // binary search for first equal position
        let first = chain_qs_fwd[0];
        if let Ok(mut st) = mini_pos.binary_search(&first) {
            // move st to the first occurrence if duplicates
            while st > 0 && mini_pos[st-1] == first { st -= 1; }
            let mut j = st;
            let mut k = 1usize;
            let mut en = st;
            let mut n_match = 1i32;
            while j + 1 < mini_pos.len() && k < chain_qs_fwd.len() {
                j += 1;
                if mini_pos[j] == chain_qs_fwd[k] { n_match += 1; en = j; k += 1; }
            }
            let mut n_tot: i32 = ((en - st) + 1) as i32;
            // edge adjustment like minimap2
            if qs2 > avg_k as i32 && ts2 > avg_k as i32 { n_tot += 1; }
            if (qseq.len() as i32 - qs2) > avg_k as i32 && (tlen as i32 - te2) > avg_k as i32 { n_tot += 1; }
            let frac = (n_match as f32) / (n_tot as f32);
            if frac >= 1.0 { dv = 0.0; }
            else { dv = 1.0 - frac.powf(1.0 / avg_k.max(1.0)); }
        }
    }
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = (rec.qstart, rec.qend);
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

```rust
use crate::seeds::{Anchor, collect_query_minimizers};
use crate::index::Index;

pub struct PafRecord<'a> {
    pub qname: &'a str,
    pub qlen: u32,
    pub qstart: u32,
    pub qend: u32,
    pub strand: char,
    pub tname: &'a str,
    pub tlen: u32,
    pub tstart: u32,
    pub tend: u32,
    pub nm: u32,
    pub blen: u32,
    pub mapq: u8,
    // tags
    pub tp: char,
    pub cm: u32,
    pub s1: u32,
    pub s2: u32,
    pub dv: f32,
    pub rl: u32,
}

#[inline]
fn qpos(a: &Anchor) -> i32 { (a.y & 0xffffffff) as i32 }
#[inline]
fn qspan(a: &Anchor) -> i32 { ((a.y >> 32) & 0xff) as i32 }
#[inline]
fn rpos(a: &Anchor) -> i32 { (a.x & 0xffffffff) as i32 }
#[inline]
fn rev(a: &Anchor) -> bool { (a.x >> 63) != 0 }

fn banded_edit_distance(q: &[u8], r: &[u8], band: usize) -> (usize, usize) {
    // Simple banded Levenshtein: returns (edits, aligned_len)
    let n = q.len(); let m = r.len();
    if n == 0 || m == 0 { return (n.max(m), n.max(m)); }
    let b = band;
    let inf = n + m + 1;
    // dp rows of size 2*b+1 centered around diagonal
    let width = 2*b+1;
    let mut prev = vec![inf; width];
    let mut curr = vec![inf; width];
    // offset diag index k = j - i, map to idx = k + b
    let idx = |i: isize, j: isize| -> Option<usize> {
        let k = j - i; if k.abs() as usize > b { return None; }
        Some((k + b as isize) as usize)
    };
    prev[b] = 0; // i=0,j=0
    for i in 0..=n {
        std::mem::swap(&mut prev, &mut curr);
        curr.fill(inf);
        let j_min = if i > b { i - b } else { 0 };
        let j_max = (i + b).min(m);
        for j in j_min..=j_max {
            let ii = i as isize; let jj = j as isize;
            let mut best = inf;
            // deletion (from q)
            if i>0 { if let Some(k) = idx(ii-1, jj) { best = best.min(prev[k] + 1); } }
            // insertion
            if j>0 { if let Some(k) = idx(ii, jj-1) { best = best.min(curr[k] + 1); } }
            // match/mismatch
            if i>0 && j>0 { if let Some(k) = idx(ii-1, jj-1) {
                let cost = if q[i-1].to_ascii_uppercase()==r[j-1].to_ascii_uppercase() {0} else {1};
                best = best.min(prev[k] + cost);
            }}
            if let Some(k) = idx(ii, jj) { curr[k] = best; }
        }
    }
    let end = idx(n as isize, m as isize);
    if let Some(k) = end {
        let edits = curr[k];
        (edits, n.max(m))
    } else {
        // outside band: fall back to maximum possible edits
        (n.max(m), n.max(m))
    }
}

fn estimate_dv_by_mismatch(q: &[u8], r: &[u8]) -> f32 {
    if q.is_empty() || r.is_empty() { return 0.0; }
    let n = q.len().min(r.len());
    let mut mis = 0usize;
    for i in 0..n { if q[i].to_ascii_uppercase() != r[i].to_ascii_uppercase() { mis += 1; } }
    (mis as f32) / (n as f32)
}

fn end_extend(idx: &Index, qseq: &[u8], rid: usize, _strand: char, mut qs: i32, mut qe: i32, mut ts: i32, mut te: i32, max_ext: i32) -> (i32,i32,i32,i32) {
    let tlen = idx.seq[rid].len as i32;
    let qlen = qseq.len() as i32;
    // left extension
    let mut ext = 0;
    while ext < max_ext && qs > 0 && ts > 0 {
        let qb = qseq[(qs-1) as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, ts-1, ts)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qs -= 1; ts -= 1; ext += 1;
    }
    // right extension
    ext = 0;
    while ext < max_ext && qe < qlen && te < tlen {
        let qb = qseq[qe as usize].to_ascii_uppercase();
        let rb = idx.get_ref_subseq(rid, te, te+1)[0].to_ascii_uppercase();
        if qb != rb { break; }
        qe += 1; te += 1; ext += 1;
    }
    (qs, qe, ts, te)
}

#[inline]
fn revcomp(seq: &[u8]) -> Vec<u8> {
    let mut out = Vec::with_capacity(seq.len());
    for &b in seq.iter().rev() {
        out.push(match b.to_ascii_uppercase() {
            b'A' => b'T',
            b'C' => b'G',
            b'G' => b'C',
            b'T' => b'A',
            _ => b'N',
        });
    }
    out
}

pub fn paf_from_chain<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8]) -> Option<PafRecord<'a>> {
    paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, true)
}

pub fn paf_from_chain_with_primary<'a>(idx: &'a Index, anchors: &[Anchor], chain: &[usize], qname: &'a str, qseq: &[u8], is_primary: bool) -> Option<PafRecord<'a>> {
    if chain.is_empty() { return None; }
    let strand = if rev(&anchors[chain[0]]) { '-' } else { '+' };
    let mut qs = i32::MAX; let mut qe = -1;
    let mut ts = i32::MAX; let mut te = -1;
    let mut cm = 0u32;
    for &i in chain {
        let a = &anchors[i];
        cm += 1;
        let s = qpos(a) - (qspan(a) - 1);
        let e = qpos(a) + 1;
        if s < qs { qs = s; } if e > qe { qe = e; }
        let rs = rpos(a) - (qspan(a) - 1);
        let re = rpos(a) + 1;
        if rs < ts { ts = rs; } if re > te { te = re; }
    }
    if qs < 0 { qs = 0; }
    if ts < 0 { ts = 0; }
    let rid0 = ((anchors[chain[0]].x >> 32) & 0x7fffffff) as usize;
    let tname = idx.seq[rid0].name.as_deref().unwrap_or("*");
    let tlen = idx.seq[rid0].len;
    // avoid end-extension to keep boundaries aligned with chaining like minimap2 pre-alignment
    let (qs2, qe2, ts2, te2) = (qs, qe, ts, te);
    let mlen = (qe2 - qs2).max(0) as u32; // approximate matches along query span
    let blen = (te2 - ts2).max(0) as u32; // alignment block length along target span
    // dv estimate following mm_est_err logic using query minimizer positions
    let mv = collect_query_minimizers(qseq, idx.w as usize, idx.k as usize);
    let mut mini_pos: Vec<i32> = Vec::with_capacity(mv.len());
    let mut sum_k: u64 = 0;
    for m in &mv { mini_pos.push(((m.rid_pos_strand >> 1) & 0xffffffff) as i32); sum_k += (m.key_span & 0xff) as u64; }
    let avg_k: f32 = if !mv.is_empty() { (sum_k as f32) / (mv.len() as f32) } else { idx.k as f32 };
    // prepare chain query positions on forward strand
    let qpos_fwd = |a: &Anchor| -> i32 {
        let qp = qpos(a);
        let qs = qspan(a);
        if rev(a) { (qseq.len() as i32) - 1 - (qp + 1 - qs) } else { qp }
    };
    let mut chain_qs_fwd: Vec<i32> = Vec::with_capacity(chain.len());
    if strand == '-' {
        for &i in chain.iter().rev() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    } else {
        for &i in chain.iter() { chain_qs_fwd.push(qpos_fwd(&anchors[i])); }
    }
    // find start index in minimizer list
    let mut dv = 0.0f32;
    if !mini_pos.is_empty() && !chain_qs_fwd.is_empty() {
        // binary search for first equal position
        let first = chain_qs_fwd[0];
        if let Ok(mut st) = mini_pos.binary_search(&first) {
            // move st to the first occurrence if duplicates
            while st > 0 && mini_pos[st-1] == first { st -= 1; }
            let mut j = st;
            let mut k = 1usize;
            let mut en = st;
            let mut n_match = 1i32;
            while j + 1 < mini_pos.len() && k < chain_qs_fwd.len() {
                j += 1;
                if mini_pos[j] == chain_qs_fwd[k] { n_match += 1; en = j; k += 1; }
            }
            let mut n_tot: i32 = ((en - st) + 1) as i32;
            // edge adjustment exactly like minimap2 (using printed coordinates)
            let r_qs_final: i32 = if strand == '-' { qseq.len() as i32 - qe2 } else { qs2 };
            let r_qe_final: i32 = if strand == '-' { qseq.len() as i32 - qs2 } else { qe2 };
            let r_rs: i32 = ts2; let r_re: i32 = te2;
            if r_qs_final > avg_k as i32 && r_rs > avg_k as i32 { n_tot += 1; }
            if (qseq.len() as i32 - r_qe_final) > avg_k as i32 && (tlen as i32 - r_re) > avg_k as i32 { n_tot += 1; }
            let frac = (n_match as f32) / (n_tot as f32);
            if frac >= 1.0 { dv = 0.0; }
            else { dv = 1.0 - frac.powf(1.0 / avg_k.max(1.0)); }
        }
    }
    let rec = PafRecord{
        qname,
        qlen: qseq.len() as u32,
        qstart: qs2 as u32,
        qend: qe2 as u32,
        strand,
        tname,
        tlen,
        tstart: ts2 as u32,
        tend: te2 as u32,
        nm: mlen,
        blen,
        mapq: 60,
        tp: if is_primary {'P'} else {'S'},
        cm,
        s1: 0,
        s2: 0,
        dv,
        rl: 0,
    };
    Some(rec)
}

pub fn write_paf(rec: &PafRecord) -> String {
    let (qs, qe) = if rec.strand == '-' {
        (rec.qlen - rec.qend, rec.qlen - rec.qstart)
    } else { (rec.qstart, rec.qend) };
    format!(
        "{q}\t{ql}\t{qs}\t{qe}\t{s}\t{t}\t{tl}\t{ts}\t{te}\t{nm}\t{bl}\t{mq}\ttp:A:{tp}\tcm:i:{cm}\ts1:i:{s1}\ts2:i:{s2}\tdv:f:{dv:.4}\trl:i:{rl}",
        q=rec.qname, ql=rec.qlen, qs=qs, qe=qe,
        s=rec.strand, t=rec.tname, tl=rec.tlen, ts=rec.tstart, te=rec.tend,
        nm=rec.nm, bl=rec.blen, mq=rec.mapq,
        tp=rec.tp, cm=rec.cm, s1=rec.s1, s2=rec.s2,
        dv=rec.dv, rl=rec.rl,
    )
}

pub fn write_paf_many_with_scores<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], top_s1: i32, top_s2: i32, qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(mut rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            rec.s1 = top_s1.max(0) as u32;
            rec.s2 = top_s2.max(0) as u32;
            out.push(write_paf(&rec));
        }
    }
    out
}

pub fn write_paf_many<'a>(idx: &'a Index, anchors: &[Anchor], chains: &[Vec<usize>], qname: &'a str, qseq: &[u8]) -> Vec<String> {
    let mut out = Vec::new();
    for (ci, chain) in chains.iter().enumerate() {
        if let Some(rec) = paf_from_chain_with_primary(idx, anchors, chain, qname, qseq, ci == 0) {
            out.push(write_paf(&rec));
        }
    }
    out
}

```

---

**User**

then i want to export mm2rs as C version of mimap2 -d option

  Indexing:
    -H           use homopolymer-compressed k-mer (preferrable for PacBio)
    -k INT       k-mer size (no larger than 28) [15]
    -w INT       minimizer window size [10]
    -I NUM       split index for every ~NUM input bases [8G]
    -d FILE      dump index to FILE []

---

**Cursor**

Adding a new CLI option to dump the index (-d) and implementing binary serialization in `Index` to save it to disk. Then I’ll build and run a quick check to ensure the option works.

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use std::collections::HashMap;
use std::io::BufRead;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        // sort and build p/h for each bucket, mirroring index.c worker_post
        for b in &mut self.B {
            if b.a.is_empty() { continue; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> self.b) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        }
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        let mut f = std::fs::File::create(path)?;
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write as little-endian u32 words
        for &w in &self.S { f.write_all(&w.to_le_bytes())?; }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            for &v in &b.p { f.write_all(&v.to_le_bytes())?; }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                for (k,v) in h.iter() { f.write_all(&k.to_le_bytes())?; f.write_all(&v.to_le_bytes())?; }
            }
        }
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w,k,b,flag);
    // read fasta (multi-seq)
    let f = std::fs::File::open(path)?; let r = std::io::BufReader::new(f);
    let mut name: Option<String> = None; let mut seq = Vec::<u8>::new();
    let mut sum_len: u64 = 0;
    let finalize_seq = |idx: &mut Index, name: &mut Option<String>, seq: &mut Vec<u8>, sum_len: &mut u64| {
        if seq.is_empty() { return; }
        // ensure S capacity
        let new_sum = *sum_len + seq.len() as u64;
        let old_max = ((*sum_len + 7) / 8) as usize; let new_max = ((new_sum + 7) / 8) as usize;
        if new_max > old_max { let new_max_ru = kroundup64(new_max); if idx.S.len() < new_max_ru { idx.S.resize(new_max_ru, 0); } }
        // pack
        for (j, ch) in seq.iter().enumerate() {
            let c = nt4(*ch);
            let o = *sum_len + j as u64; mm_seq4_set(&mut idx.S, o, c);
        }
        // push seq meta
        idx.seq.push(IndexSeq{ name: name.clone(), offset: *sum_len, len: seq.len() as u32, is_alt: false });
        idx.n_seq += 1; *sum_len = new_sum;
        // sketch and add
        let mut a: Vec<Minimizer> = Vec::new();
        if seq.len() > 0 { sketch_sequence(&seq, w as usize, k as usize, idx.n_seq-1, (flag&1)!=0, &mut a); }
        idx.add_minimizers(&a);
        seq.clear();
    };
    for line in r.lines() { let line = line?; if line.starts_with('>') { finalize_seq(&mut idx, &mut name, &mut seq, &mut sum_len); name = Some(line[1..].trim().to_string()); } else { seq.extend_from_slice(line.trim().as_bytes()); } }
    finalize_seq(&mut idx, &mut name, &mut seq, &mut sum_len);
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

---

**User**

Then the index option can use the dump binary index as reference

---

**Cursor**

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/main.rs
@@
-use mm2rs::index::build_index_from_fasta;
+use mm2rs::index::build_index_from_fasta;
 use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
 use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
 use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
 use std::fs::File;
 use std::io::{BufRead, BufReader};
 use std::io::Write;
@@
 fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
@@
 }
 
+fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
+    // Try loading binary index first; if fails, build from FASTA
+    match Index::load_from_file(path) {
+        Ok(idx) => Ok(idx),
+        Err(_) => build_index_from_fasta(path, w, k, b, flag),
+    }
+}
+
 fn main() -> anyhow::Result<()> {
@@
-        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
-            let flag = if hpc {1} else {0};
-            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
+        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
+            let flag = if hpc {1} else {0};
+            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
             let (_qname, q) = read_fasta_first(&qry_fasta)?;
             let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
             filter_query_minimizers(&mut mv, 10, 0.01);
             let mut mid_occ = idx.calc_mid_occ(2e-4f32);
             if mid_occ < 10 { mid_occ = 10; }
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
             println!("anchors: {}", anchors.len());
             for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
         }
         Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
             let flag = if hpc {1} else {0};
-            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
+            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
             let (_qname, q) = read_fasta_first(&qry_fasta)?;
             let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
             filter_query_minimizers(&mut mv, 10, 0.01);
             let mut mid_occ = idx.calc_mid_occ(2e-4f32);
             if mid_occ < 10 { mid_occ = 10; }
             let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
             let mut p = default_chain_params(k); p.bw = bw; // allow override bw
             let chain = chain_dp(&anchors, &p);
             println!("best_chain_len: {}", chain.len());
             if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                 println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                 println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
             }
         }
         Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
             if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
             let flag = if hpc {1} else {0};
-            let idx = build_index_from_fasta(&ref_fasta, w, k, 14, flag)?;
+            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
             let (qname, q) = read_fasta_first(&qry_fasta)?;
             let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
             filter_query_minimizers(&mut mv, 10, 0.01);
             let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
             if mid_occ < 10 { mid_occ = 10; }
*** End Patch
```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use std::io::{BufRead, BufReader};
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let f = File::open(path)?; let r = BufReader::new(f);
    let mut name = String::from("*");
    let mut seq = Vec::new();
    for line in r.lines() {
        let line = line?;
        if line.starts_with('>') { if name == "*" { name = line[1..].trim().to_string(); } continue; }
        seq.extend_from_slice(line.trim().as_bytes());
    }
    Ok((name, seq))
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

