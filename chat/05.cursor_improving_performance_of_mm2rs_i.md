# Improving performance of mm2rs implementation
_Exported on 8/8/2025 at 15:30:46 GMT+8 from Cursor (1.4.2)_

---

**User**

i write a rust version of minimap2 (mm2rs) , and i Found it is too slow. I think the fasta read is one of the problem. you can use @https://github.com/zaeleus/noodles  for effective fasta load. and you should use multi-threads to speed up.

$ time ./minimap2/minimap2 -v0 -d test/index  test/genome.fa 
./minimap2/minimap2 -v0 -d test/index test/genome.fa  10.30s user 1.62s system 151% cpu 7.870 total
(base) 
# xzg @ DESKTOP-AK4KKMM in ~/project/minimap2_rs2 [14:47:54] 
$ time ./mm2rs/target/release/mm2rs index -d test/index2 test/genome.fa 
kmer size: 15; skip: 10; is_hpc: 0; #seq: 2
distinct minimizers: 27981683 (avg occ 1.87) avg spacing 5.320 total length 278413945
./mm2rs/target/release/mm2rs index -d test/index2 test/genome.fa  19.34s user 111.76s system 99% cpu 2:11.15 total

---

**Cursor**

I'll scan the codebase to locate the current FASTA reading logic and related index-building paths, and check for any existing multithreading infrastructure. Then I'll open the key files to plan the integration of `noodles` and parallel processing.

I'll add noodles-fasta and rayon, replace the line-based FASTA parser with noodles' streaming reader, and parallelize minimizer sketching per sequence. Then I'll update `build_index_from_fasta` accordingly.

I'll integrate `noodles-fasta` for efficient FASTA reading, add `rayon` for parallelism, refactor `build_index_from_fasta` to read records via noodles, compute minimizers per-sequence in parallel, pack sequences, and parallelize the bucket post-processing. I'll also switch `read_fasta_first` to noodles. Then I'll run the build to ensure it compiles.

```plaintext
[package]
name = "mm2rs"
version = "0.1.0"
edition = "2021"

[dependencies]
memmap2 = "0.9"
thiserror = "1.0"
clap = { version = "4.5", features = ["derive"] }
anyhow = "1.0"
rayon = "1.8"
noodles-fasta = { git = "https://github.com/zaeleus/noodles" }

[dev-dependencies]
assert_cmd = "2.0"

```

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        let mut f = std::fs::File::create(path)?;
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write as little-endian u32 words
        for &w in &self.S { f.write_all(&w.to_le_bytes())?; }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            for &v in &b.p { f.write_all(&v.to_le_bytes())?; }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                for (k,v) in h.iter() { f.write_all(&k.to_le_bytes())?; f.write_all(&v.to_le_bytes())?; }
            }
        }
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let mut reader = FastaReader::from_path(path)?;
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(record.name().to_string());
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use noodles_fasta::io::Reader as FastaReader;
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let mut reader = FastaReader::from_path(path)?;
    if let Some(result) = reader.records().next() {
        let record = result?;
        let name = record.name().to_string();
        let seq = record.sequence().as_ref().to_vec();
        Ok((name, seq))
    } else {
        Ok(("*".to_string(), Vec::new()))
    }
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use std::fs::File;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        let mut f = std::fs::File::create(path)?;
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write as little-endian u32 words
        for &w in &self.S { f.write_all(&w.to_le_bytes())?; }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            for &v in &b.p { f.write_all(&v.to_le_bytes())?; }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                for (k,v) in h.iter() { f.write_all(&k.to_le_bytes())?; f.write_all(&v.to_le_bytes())?; }
            }
        }
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let mut reader = FastaReader::new(File::open(path)?);
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(record.name().to_string());
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use noodles_fasta::io::Reader as FastaReader;
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    let mut reader = FastaReader::new(File::open(path)?);
    if let Some(result) = reader.records().next() {
        let record = result?;
        let name = record.name().to_string();
        let seq = record.sequence().as_ref().to_vec();
        Ok((name, seq))
    } else {
        Ok(("*".to_string(), Vec::new()))
    }
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

```rust
*** Begin Patch
*** Update File: /home/xzg/project/minimap2_rs2/mm2rs/src/index.rs
@@
-use noodles_fasta::io::Reader as FastaReader;
+use noodles_fasta::io::Reader as FastaReader;
 use rayon::prelude::*;
 use std::collections::HashMap;
 use std::io::{Write, Read};
+use std::io::BufReader;
@@
-    let mut reader = FastaReader::new(File::open(path)?);
-    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
-    for result in reader.records() {
+    let file = File::open(path)?;
+    let mut reader = FastaReader::new(BufReader::new(file));
+    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
+    let mut recs = reader.records();
+    while let Some(result) = recs.next() {
         let record = result?;
         let name = Some(record.name().to_string());
         let seq = record.sequence().as_ref().to_vec();
-        records.push((name, seq));
-    }
+        records.push((name, seq));
+    }
*** End Patch
```

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use std::fs::File;
use std::io::BufReader;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        let mut f = std::fs::File::create(path)?;
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write as little-endian u32 words
        for &w in &self.S { f.write_all(&w.to_le_bytes())?; }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            for &v in &b.p { f.write_all(&v.to_le_bytes())?; }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                for (k,v) in h.iter() { f.write_all(&k.to_le_bytes())?; f.write_all(&v.to_le_bytes())?; }
            }
        }
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let file = File::open(path)?;
    let mut reader = FastaReader::new(BufReader::new(file));
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(record.name().to_string());
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use noodles_fasta::io::Reader as FastaReader;
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    use std::io::BufReader;
    let mut reader = FastaReader::new(BufReader::new(File::open(path)?));
    if let Some(result) = reader.records().next() {
        let record = result?;
        let name = record.name().to_string();
        let seq = record.sequence().as_ref().to_vec();
        Ok((name, seq))
    } else {
        Ok(("*".to_string(), Vec::new()))
    }
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use std::fs::File;
use std::io::BufReader;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        let mut f = std::fs::File::create(path)?;
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write as little-endian u32 words
        for &w in &self.S { f.write_all(&w.to_le_bytes())?; }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            for &v in &b.p { f.write_all(&v.to_le_bytes())?; }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                for (k,v) in h.iter() { f.write_all(&k.to_le_bytes())?; f.write_all(&v.to_le_bytes())?; }
            }
        }
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let file = File::open(path)?;
    let mut reader = FastaReader::new(BufReader::new(file));
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(String::from_utf8(record.name().to_vec()).unwrap_or_else(|_| "*".to_string()));
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use noodles_fasta::io::Reader as FastaReader;
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    use std::io::BufReader;
    let mut reader = FastaReader::new(BufReader::new(File::open(path)?));
    if let Some(result) = reader.records().next() {
        let record = result?;
        let name = String::from_utf8(record.name().to_vec()).unwrap_or_else(|_| "*".to_string());
        let seq = record.sequence().as_ref().to_vec();
        Ok((name, seq))
    } else {
        Ok(("*".to_string(), Vec::new()))
    }
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() { idx.save_to_file(path)?; }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

Status: Replaced line-based FASTA parsing with noodles, added Rayon, parallelized minimizer sketching and bucket post-processing, and preallocated packed sequence storage to cut syscalls. Build is green.

What I changed
- Added crates:
  - `noodles-fasta` (from repo) and `rayon` in `mm2rs/Cargo.toml`.
- Switched FASTA I/O to noodles:
  - `build_index_from_fasta` now uses `noodles_fasta::io::Reader<BufReader<File>>`.
  - `read_fasta_first` also uses noodles.
- Performance:
  - Precompute all sequences first; allocate `Index.S` once from total length.
  - Parallel minimizer sketching per sequence (Rayon).
  - Parallel bucket post-processing (`Index::post_process`) across buckets.

How to build and try
- Build:
  - cd /home/xzg/project/minimap2_rs2/mm2rs && cargo build --release | cat
- Index with timing:
  - time /home/xzg/project/minimap2_rs2/mm2rs/target/release/mm2rs index -d /home/xzg/project/minimap2_rs2/test/index2.noodles /home/xzg/project/minimap2_rs2/test/genome.fa
- Control threads (optional):
  - RAYON_NUM_THREADS=4 time mm2rs index 

Reference
- FASTA I/O via noodles: [noodles repo](https://github.com/zaeleus/noodles)

Notes
- The big sys time in your run was likely repeated `Vec` growth and line-by-line parsing. Now we allocate `S` once and stream decode via noodles; plus multi-threaded sketching and bucket processing.
- You can compare wall-clock vs minimap2 again; for large references expect a substantial drop in system time.

Summary
- Integrated `noodles-fasta` and `rayon`.
- Parallelized sequence sketching and bucket post-processing.
- Preallocated packed sequence buffer.
- Build passes; ready to benchmark with your genome.

---

**User**

time ./mm2rs/target/release/mm2rs index -d test/index test/genome.fa
kmer size: 15; skip: 10; is_hpc: 0; #seq: 2
distinct minimizers: 27981683 (avg occ 1.87) avg spacing 5.320 total length 278413945
./mm2rs/target/release/mm2rs index -d test/index test/genome.fa  21.84s user 110.73s system 104% cpu 2:06.85 total

time ./minimap2/minimap2 -v0 -d test/index  test/genome.fa
./minimap2/minimap2 -v0 -d test/index test/genome.fa  11.15s user 1.77s system 145% cpu 8.878 total

why  our aproach is too slow

---

**Cursor**

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use std::fs::File;
use std::io::BufReader;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        use std::io::Write as _;
        let mut f = std::io::BufWriter::new(std::fs::File::create(path)?);
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write S in large buffered chunks
        const CHUNK_WORDS: usize = 1 << 16; // 65,536 u32 (~256 KiB of bytes per chunk)
        let mut i = 0usize;
        let s_len_words = self.S.len();
        let mut buf: Vec<u8> = Vec::with_capacity(CHUNK_WORDS * 4);
        while i < s_len_words {
            let end = (i + CHUNK_WORDS).min(s_len_words);
            buf.clear();
            for &w in &self.S[i..end] { buf.extend_from_slice(&w.to_le_bytes()); }
            f.write_all(&buf)?;
            i = end;
        }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            // write p in chunks
            let mut i = 0usize;
            let mut buf: Vec<u8> = Vec::with_capacity(CHUNK_WORDS * 8);
            while i < b.p.len() {
                let end = (i + CHUNK_WORDS).min(b.p.len());
                buf.clear();
                for &v in &b.p[i..end] { buf.extend_from_slice(&v.to_le_bytes()); }
                f.write_all(&buf)?;
                i = end;
            }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                // write hashmap entries buffered
                let mut i = 0usize;
                let mut buf: Vec<u8> = Vec::with_capacity(2 * CHUNK_WORDS * 8);
                for (k, v) in h.iter() {
                    let _ = i; // silence unused in some branches
                    buf.extend_from_slice(&k.to_le_bytes());
                    buf.extend_from_slice(&v.to_le_bytes());
                    if buf.len() >= 2 * CHUNK_WORDS * 8 {
                        f.write_all(&buf)?; buf.clear();
                    }
                }
                if !buf.is_empty() { f.write_all(&buf)?; }
            }
        }
        f.flush()?;
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let file = File::open(path)?;
    let mut reader = FastaReader::new(BufReader::new(file));
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(String::from_utf8(record.name().to_vec()).unwrap_or_else(|_| "*".to_string()));
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

### Why its slow (quick diagnosis)

- Excessive index file syscalls: your `save_to_file` wrote each `u32`/`u64` separately, causing millions of tiny writes  huge system time. I switched it to buffered, chunked writes via `BufWriter` and large byte buffers. Expect system time to drop dramatically.
- Non-overlapped pipeline: minimap2 overlaps IO, minimizer collection, and sorting in a 3-stage pipeline with threads. We previously did them mostly serially, which increases wall time even if CPU is similar.
- Per-line FASTA parsing (before): created many small allocations and syscalls. We changed to `noodles-fasta` streaming reader, which is faster and more cache-friendly. Ref: `noodles` repo [link](https://github.com/zaeleus/noodles).
- Push-all then post-process: we still push all minimizers into buckets, then sort each bucket. Minimap2 pre-sizes/partitions and reduces allocations. Our approach allocates and copies more than needed.

### What changed in code
- FASTA I/O: replaced line-by-line with `noodles_fasta::io::Reader<BufReader<File>>`.
- Parallelism: minimizer sketching per sequence is parallel; bucket post-processing is parallel.
- Index writing: now buffered, chunked writes for `S`, `p`, and `h` to avoid tiny write syscalls.

### What to try now
- Re-run the same command to measure the impact of buffered writes:
  - time /home/xzg/project/minimap2_rs2/mm2rs/target/release/mm2rs index -d /home/xzg/project/minimap2_rs2/test/index /home/xzg/project/minimap2_rs2/test/genome.fa
- If still slow, isolate I/O vs compute:
  - Without `-d` (no index dump) to see pure build cost.
  - With `RAYON_NUM_THREADS` tuned (e.g., 48) to see scaling and avoid oversubscription on WSL2.

### Further speedups (next steps)
- Parallelize bucket fill: partition minimizers by bucket in parallel, build per-bucket vectors, then merge, avoiding contention and reducing reallocations.
- Pre-size per-bucket arrays: estimate counts via a first pass over keys to allocate `a`/`p` capacity, then fill once.
- Pipeline stages: overlap FASTA read, sketch, and bucket merge with a bounded channel (emulating minimap2s 3-stage pipeline).
- Optional: mmap or single large write for `S` and `p` if the FS benefits.

Summary
- Root cause: tiny write syscalls and non-overlapped pipeline; previously also per-line FASTA parsing.
- Fixes applied: noodles FASTA, parallel sketch, parallel post-process, buffered chunked index writes.
- Action: rerun timing; system time should fall substantially. If needed, we can parallelize bucket fill and add a 3-stage pipeline next.

---

**User**

can C version minimap2 use the binary dump of Rust minimap2

---

**Cursor**

Short answer: No, not as-is.

- Your Rust dump uses a different magic and layout (`"MM2RSIDX\0"` plus custom sections). C minimap2 expects the MMI format with magic `"MMI\x02"` and a specific record order. It will reject your file at the magic check and even if bypassed, the layout differs.

Key points from minimap2 C code (what it expects):
```481:514:minimap2/index.c
fwrite(MM_IDX_MAGIC, 1, 4, fp);
fwrite(x, 4, 5, fp); // w,k,b,n_seq,flag (u32 each)
for (i = 0; i < mi->n_seq; ++i) {
  // name length (u8), name bytes, len (u32). Offsets are implied by cumulative lengths.
}
for (i = 0; i < 1<<mi->b; ++i) {
  fwrite(&b->n, 4, 1, fp);           // u32
  fwrite(b->p, 8, b->n, fp);         // u64[b->n]
  fwrite(&size, 4, 1, fp);           // u32, number of hash entries
  for (...) fwrite(x, 8, 2, fp);     // (key, val) as two u64 per entry
}
if (!(mi->flag & MM_I_NO_SEQ))
  fwrite(mi->S, 4, (sum_len + 7) / 8, fp); // packed sequence words (u32)
fflush(fp);
```

Magic check on load:
```523:526:minimap2/index.c
if (fread(magic, 1, 4, fp) != 4) return 0;
if (strncmp(magic, MM_IDX_MAGIC, 4) != 0) return 0; // MM_IDX_MAGIC = "MMI\x02"
```

What to do
- Implement an MMI writer in Rust (e.g., `Index::save_to_mmi(path)`), mirroring `mm_idx_dump` exactly:
  - Write `"MMI\x02"`, then 5u32 header: `w,k,b,n_seq,flag`
  - For each sequence: u8 name_len + name bytes (0 if none), then u32 len
  - For each bucket `0..(1<<b)`: u32 `n` (= p.len), u64 array `p`, u32 `size` (= number of hashmap entries), then exactly `size` key/value pairs (two u64 each)
  - Finally write `S` as u32 words of length `(sum_len + 7)/8`
- Optionally implement an MMI loader to read C-built indices.

If you want, I can add `save_to_mmi` and a CLI flag to emit a `.mmi` that C minimap2 can consume.

```c
fwrite(MM_IDX_MAGIC, 1, 4, fp);
fwrite(x, 4, 5, fp); // w,k,b,n_seq,flag (u32 each)
for (i = 0; i < mi->n_seq; ++i) {
  // name length (u8), name bytes, len (u32). Offsets are implied by cumulative lengths.
}
for (i = 0; i < 1<<mi->b; ++i) {
  fwrite(&b->n, 4, 1, fp);           // u32
  fwrite(b->p, 8, b->n, fp);         // u64[b->n]
  fwrite(&size, 4, 1, fp);           // u32, number of hash entries
  for (...) fwrite(x, 8, 2, fp);     // (key, val) as two u64 per entry
}
if (!(mi->flag & MM_I_NO_SEQ))
  fwrite(mi->S, 4, (sum_len + 7) / 8, fp); // packed sequence words (u32)
fflush(fp);
```

```c
if (fread(magic, 1, 4, fp) != 4) return 0;
if (strncmp(magic, MM_IDX_MAGIC, 4) != 0) return 0; // MM_IDX_MAGIC = "MMI\x02"
```

---

**User**

C

---

**Cursor**

```rust
use crate::sketch::{sketch_sequence, Minimizer};
use crate::nt4::nt4;
use noodles_fasta::io::Reader as FastaReader;
use std::fs::File;
use std::io::BufReader;
use rayon::prelude::*;
use std::collections::HashMap;
use std::io::{Write, Read};

#[inline]
fn kroundup64(mut x: usize) -> usize { x-=1; x|=x>>1; x|=x>>2; x|=x>>4; x|=x>>8; x|=x>>16; x|=x>>32; x+1 }

#[inline]
fn mm_seq4_set(S: &mut [u32], o: u64, c: u8) {
    let i = (o >> 3) as usize; // every u32 packs 8 bases
    let shift = ((o & 7) << 2) as usize;
    let v = S[i];
    S[i] = (v & !(0xFu32 << shift)) | (((c as u32) & 0xF) << shift);
}

#[inline]
fn mm_seq4_get(S: &[u32], o: u64) -> u8 {
    let i = (o >> 3) as usize;
    let shift = ((o & 7) << 2) as usize;
    ((S[i] >> shift) & 0xF) as u8
}

#[derive(Clone)]
pub struct IndexSeq { pub name: Option<String>, pub offset: u64, pub len: u32, pub is_alt: bool }

struct Bucket { a: Vec<Minimizer>, p: Vec<u64>, h: Option<HashMap<u64,u64>> }

pub struct Index {
    pub w: i32,
    pub k: i32,
    pub b: i32,
    pub flag: i32,
    pub n_seq: u32,
    pub seq: Vec<IndexSeq>,
    pub S: Vec<u32>,
    B: Vec<Bucket>,
}

pub enum Occurrences<'a> { Single(u64), Multi(&'a [u64]) }

impl Index {
    pub fn new(w: i32, k: i32, b: i32, flag: i32) -> Self {
        let mut B = Vec::with_capacity(1usize << b);
        for _ in 0..(1usize<<b) { B.push(Bucket{ a:Vec::new(), p:Vec::new(), h:None }); }
        Self{ w, k, b, flag, n_seq: 0, seq: Vec::new(), S: Vec::new(), B }
    }

    pub fn get_ref_subseq(&self, rid: usize, st: i32, en: i32) -> Vec<u8> {
        let mut out = Vec::new();
        if rid >= self.seq.len() { return out; }
        let s = &self.seq[rid];
        let mut st0 = st.max(0) as u64;
        let mut en0 = en.min(s.len as i32).max(0) as u64;
        if st0 >= en0 { return out; }
        st0 += s.offset; en0 += s.offset;
        for o in st0..en0 {
            let c = mm_seq4_get(&self.S, o);
            let b = match c { 0=>b'A', 1=>b'C', 2=>b'G', 3=>b'T', _=>b'N' };
            out.push(b);
        }
        out
    }

    fn add_minimizers(&mut self, v: &[Minimizer]) {
        let mask = (1u64 << self.b) - 1;
        for m in v { let idx = ((m.key_span >> 8) & mask as u64) as usize; self.B[idx].a.push(*m); }
    }

    fn post_process(&mut self) {
        let b_bits = self.b;
        // parallel over buckets
        self.B.par_iter_mut().for_each(|b| {
            if b.a.is_empty() { return; }
            b.a.sort_by_key(|x| x.key_span >> 8);
            // count
            let mut n: i32 = 1; let mut n_keys: i32 = 0; let mut total_p: usize = 0;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) { n_keys+=1; if n>1 { total_p += n as usize; } n=1; } else { n+=1; }
            }
            b.p = vec![0u64; total_p];
            let mut h: HashMap<u64,u64> = HashMap::with_capacity(n_keys as usize);
            // fill
            n=1; let mut start_a = 0usize; let mut start_p = 0usize;
            for j in 1..=b.a.len() {
                if j==b.a.len() || (b.a[j].key_span>>8)!=(b.a[j-1].key_span>>8) {
                    let p = b.a[j-1];
                    let key_top = ((p.key_span>>8) >> b_bits) << 1; // minier>>b << 1
                    if n==1 {
                        h.insert(key_top | 1, p.rid_pos_strand);
                    } else {
                        for k in 0..n { b.p[start_p + k as usize] = b.a[start_a + k as usize].rid_pos_strand; }
                        // sort positions by y
                        b.p[start_p..start_p + n as usize].sort_unstable();
                        let val = ((start_p as u64) << 32) | (n as u64);
                        h.insert(key_top, val);
                        start_p += n as usize;
                    }
                    start_a = j; n=1;
                } else { n+=1; }
            }
            b.h = Some(h);
            b.a.clear();
        });
    }

    pub fn stats(&self) -> (u64, f64, f64, u64) {
        // distinct minimizers n, avg occurrences, avg spacing, total length
        let mut n_keys: u64 = 0;
        let mut sum_occ: u64 = 0;
        for b in &self.B {
            if let Some(ref h) = b.h { for (k,v) in h.iter() { if (k & 1) == 1 { n_keys += 1; sum_occ += 1; } else { n_keys += 1; sum_occ += (*v & 0xffffffff) as u64; } } }
        }
        let mut total_len: u64 = 0; for s in &self.seq { total_len += s.len as u64; }
        let avg_occ = if n_keys>0 { (sum_occ as f64)/(n_keys as f64) } else { 0.0 };
        let avg_spacing = if sum_occ>0 { (total_len as f64)/(sum_occ as f64) } else { 0.0 };
        (n_keys, avg_occ, avg_spacing, total_len)
    }

    pub fn calc_mid_occ(&self, frac: f32) -> i32 {
        // similar to mm_idx_cal_max_occ: find threshold so that (1-frac) quantile of occurrences
        let mut counts: Vec<u32> = Vec::new();
        for b in &self.B {
            if let Some(ref h) = b.h {
                for (k, v) in h.iter() {
                    let c = if (k & 1) == 1 { 1 } else { (*v & 0xffffffff) as u32 };
                    counts.push(c);
                }
            }
        }
        if counts.is_empty() { return i32::MAX; }
        counts.sort_unstable();
        let n = counts.len();
        let idx = ((1.0 - frac as f64) * (n as f64)) as usize;
        let idx = idx.min(n-1);
        (counts[idx] as i32) + 1
    }

    pub fn get<'a>(&'a self, minier: u64) -> Option<Occurrences<'a>> {
        let mask = (1u64 << self.b) - 1;
        let b = &self.B[(minier & mask) as usize];
        let h = b.h.as_ref()?;
        let key = ((minier >> self.b) << 1) as u64;
        if let Some(&val) = h.get(&(key | 1)) { return Some(Occurrences::Single(val)); }
        if let Some(&val) = h.get(&key) {
            let off = (val >> 32) as usize; let n = (val & 0xffffffff) as usize;
            return Some(Occurrences::Multi(&b.p[off..off+n]));
        }
        None
    }

    pub fn save_to_file(&self, path: &str) -> anyhow::Result<()> {
        use std::io::Write as _;
        let mut f = std::io::BufWriter::new(std::fs::File::create(path)?);
        // header
        f.write_all(b"MM2RSIDX\0")?; // magic 9 bytes
        f.write_all(&1u32.to_le_bytes())?; // version
        // basic params
        f.write_all(&self.w.to_le_bytes())?;
        f.write_all(&self.k.to_le_bytes())?;
        f.write_all(&self.b.to_le_bytes())?;
        f.write_all(&self.flag.to_le_bytes())?;
        f.write_all(&self.n_seq.to_le_bytes())?;
        // sequences
        let n_seq = self.seq.len() as u32;
        f.write_all(&n_seq.to_le_bytes())?;
        for s in &self.seq {
            let has_name: u8 = if s.name.is_some() {1} else {0};
            f.write_all(&has_name.to_le_bytes())?;
            if let Some(ref name) = s.name {
                let len = name.len() as u32; f.write_all(&len.to_le_bytes())?; f.write_all(name.as_bytes())?;
            }
            f.write_all(&s.offset.to_le_bytes())?;
            f.write_all(&s.len.to_le_bytes())?;
            f.write_all(&(if s.is_alt {1u8} else {0u8}).to_le_bytes())?;
        }
        // packed sequence array
        let s_len = self.S.len() as u64; f.write_all(&s_len.to_le_bytes())?;
        // write S in large buffered chunks
        const CHUNK_WORDS: usize = 1 << 16; // 65,536 u32 (~256 KiB of bytes per chunk)
        let mut i = 0usize;
        let s_len_words = self.S.len();
        let mut buf: Vec<u8> = Vec::with_capacity(CHUNK_WORDS * 4);
        while i < s_len_words {
            let end = (i + CHUNK_WORDS).min(s_len_words);
            buf.clear();
            for &w in &self.S[i..end] { buf.extend_from_slice(&w.to_le_bytes()); }
            f.write_all(&buf)?;
            i = end;
        }
        // buckets
        let nb = self.B.len() as u32; f.write_all(&nb.to_le_bytes())?;
        for b in &self.B {
            // positions array p
            let p_len = b.p.len() as u64; f.write_all(&p_len.to_le_bytes())?;
            // write p in chunks
            let mut i = 0usize;
            let mut buf: Vec<u8> = Vec::with_capacity(CHUNK_WORDS * 8);
            while i < b.p.len() {
                let end = (i + CHUNK_WORDS).min(b.p.len());
                buf.clear();
                for &v in &b.p[i..end] { buf.extend_from_slice(&v.to_le_bytes()); }
                f.write_all(&buf)?;
                i = end;
            }
            // hash map h
            let has_h: u8 = if b.h.is_some() {1} else {0}; f.write_all(&has_h.to_le_bytes())?;
            if let Some(ref h) = b.h {
                let h_len = h.len() as u64; f.write_all(&h_len.to_le_bytes())?;
                // write hashmap entries buffered
                let mut i = 0usize;
                let mut buf: Vec<u8> = Vec::with_capacity(2 * CHUNK_WORDS * 8);
                for (k, v) in h.iter() {
                    let _ = i; // silence unused in some branches
                    buf.extend_from_slice(&k.to_le_bytes());
                    buf.extend_from_slice(&v.to_le_bytes());
                    if buf.len() >= 2 * CHUNK_WORDS * 8 {
                        f.write_all(&buf)?; buf.clear();
                    }
                }
                if !buf.is_empty() { f.write_all(&buf)?; }
            }
        }
        f.flush()?;
        Ok(())
    }

    // Write index in minimap2 MMI format (compatible with C mm_idx_dump/mm_idx_load)
    pub fn save_to_mmi(&self, path: &str) -> anyhow::Result<()> {
        use std::io::Write as _;
        let mut f = std::io::BufWriter::new(std::fs::File::create(path)?);
        // header: magic + 5 x u32 (w,k,b,n_seq,flag)
        f.write_all(b"MMI\x02")?;
        let w = self.w as u32;
        let k = self.k as u32;
        let b = self.b as u32;
        let n_seq = self.seq.len() as u32;
        let flag = self.flag as u32;
        for v in [w, k, b, n_seq, flag] { f.write_all(&v.to_le_bytes())?; }
        // sequences: name length (u8), name bytes, len (u32). Offset is implied.
        let mut sum_len: u64 = 0;
        for s in &self.seq {
            if let Some(ref name) = s.name {
                let l = name.len().min(255) as u8; // cap at 255 like C's uint8_t
                f.write_all(&[l])?;
                f.write_all(&name.as_bytes()[..l as usize])?;
            } else {
                f.write_all(&[0u8])?;
            }
            f.write_all(&s.len.to_le_bytes())?;
            sum_len += s.len as u64;
        }
        // buckets: for i in 0..(1<<b): write n (u32), p (u64[n]), size (u32), then size entries of (key,u64,val,u64)
        let nb: usize = 1usize << self.b;
        // Write in bucket-index order to match C
        for i in 0..nb {
            let bkt = &self.B[i];
            let n = bkt.p.len() as u32;
            f.write_all(&n.to_le_bytes())?;
            // write p array buffered
            if n > 0 {
                const CHUNK: usize = 1 << 16;
                let mut off = 0usize;
                let mut buf: Vec<u8> = Vec::with_capacity(CHUNK * 8);
                while off < bkt.p.len() {
                    let end = (off + CHUNK).min(bkt.p.len());
                    buf.clear();
                    for &v in &bkt.p[off..end] { buf.extend_from_slice(&v.to_le_bytes()); }
                    f.write_all(&buf)?;
                    off = end;
                }
            }
            let size = bkt.h.as_ref().map(|h| h.len() as u32).unwrap_or(0u32);
            f.write_all(&size.to_le_bytes())?;
            if let Some(ref h) = bkt.h {
                // write each (key,val)
                let mut buf: Vec<u8> = Vec::with_capacity(2 * 1024);
                for (k, v) in h.iter() {
                    buf.extend_from_slice(&k.to_le_bytes());
                    buf.extend_from_slice(&v.to_le_bytes());
                    if buf.len() >= 2 * 1024 { f.write_all(&buf)?; buf.clear(); }
                }
                if !buf.is_empty() { f.write_all(&buf)?; }
            }
        }
        // packed sequence array at the end, unless NO_SEQ
        if (self.flag & 0) == 0 { // we always include sequences; C checks NO_SEQ bit itself
            let words = ((sum_len + 7) / 8) as usize;
            // write exactly words entries from S (S may be slightly larger due to rounding)
            const CHUNK: usize = 1 << 16;
            let mut off = 0usize;
            let mut buf: Vec<u8> = Vec::with_capacity(CHUNK * 4);
            while off < words {
                let end = (off + CHUNK).min(words);
                buf.clear();
                for &w in &self.S[off..end] { buf.extend_from_slice(&w.to_le_bytes()); }
                f.write_all(&buf)?;
                off = end;
            }
        }
        f.flush()?;
        Ok(())
    }

    pub fn load_from_file(path: &str) -> anyhow::Result<Index> {
        let mut f = std::fs::File::open(path)?;
        let mut magic = [0u8; 9]; f.read_exact(&mut magic)?;
        if &magic != b"MM2RSIDX\0" { anyhow::bail!("invalid index file magic"); }
        let mut u32buf = [0u8; 4];
        f.read_exact(&mut u32buf)?; let _ver = u32::from_le_bytes(u32buf);
        // params
        let mut i32buf = [0u8; 4];
        f.read_exact(&mut i32buf)?; let w = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let k = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let b = i32::from_le_bytes(i32buf);
        f.read_exact(&mut i32buf)?; let flag = i32::from_le_bytes(i32buf);
        f.read_exact(&mut u32buf)?; let n_seq_decl = u32::from_le_bytes(u32buf);
        // sequences
        f.read_exact(&mut u32buf)?; let n_seq = u32::from_le_bytes(u32buf) as usize;
        let mut seq = Vec::with_capacity(n_seq);
        for _ in 0..n_seq {
            let mut u8buf = [0u8;1]; f.read_exact(&mut u8buf)?; let has_name = u8buf[0] != 0;
            let name = if has_name {
                f.read_exact(&mut u32buf)?; let l = u32::from_le_bytes(u32buf) as usize;
                let mut nb = vec![0u8; l]; f.read_exact(&mut nb)?; Some(String::from_utf8(nb).unwrap_or_else(|_| String::from("*")))
            } else { None };
            let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let offset = u64::from_le_bytes(u64buf);
            f.read_exact(&mut u32buf)?; let len = u32::from_le_bytes(u32buf);
            let mut u8b = [0u8;1]; f.read_exact(&mut u8b)?; let is_alt = u8b[0] != 0;
            seq.push(IndexSeq{ name, offset, len, is_alt });
        }
        // packed sequence array
        let mut u64buf = [0u8;8]; f.read_exact(&mut u64buf)?; let s_len_words = u64::from_le_bytes(u64buf) as usize;
        let mut S = vec![0u32; s_len_words];
        for i in 0..s_len_words { let mut wbuf=[0u8;4]; f.read_exact(&mut wbuf)?; S[i] = u32::from_le_bytes(wbuf); }
        // buckets
        f.read_exact(&mut u32buf)?; let nb = u32::from_le_bytes(u32buf) as usize;
        let mut B: Vec<Bucket> = Vec::with_capacity(nb);
        for _ in 0..nb {
            f.read_exact(&mut u64buf)?; let p_len = u64::from_le_bytes(u64buf) as usize;
            let mut p = vec![0u64; p_len];
            for i in 0..p_len { let mut buf=[0u8;8]; f.read_exact(&mut buf)?; p[i] = u64::from_le_bytes(buf); }
            let mut u8b=[0u8;1]; f.read_exact(&mut u8b)?; let has_h = u8b[0] != 0;
            let mut h: Option<HashMap<u64,u64>> = None;
            if has_h {
                f.read_exact(&mut u64buf)?; let h_len = u64::from_le_bytes(u64buf) as usize;
                let mut map: HashMap<u64,u64> = HashMap::with_capacity(h_len);
                for _ in 0..h_len { let mut kb=[0u8;8]; let mut vb=[0u8;8]; f.read_exact(&mut kb)?; f.read_exact(&mut vb)?; map.insert(u64::from_le_bytes(kb), u64::from_le_bytes(vb)); }
                h = Some(map);
            }
            B.push(Bucket{ a: Vec::new(), p, h });
        }
        Ok(Index{ w,k,b,flag, n_seq: n_seq_decl, seq, S, B })
    }
}

pub fn build_index_from_fasta(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    let mut idx = Index::new(w, k, b, flag);
    // Read all records using noodles
    let file = File::open(path)?;
    let mut reader = FastaReader::new(BufReader::new(file));
    let mut records: Vec<(Option<String>, Vec<u8>)> = Vec::new();
    for result in reader.records() {
        let record = result?;
        let name = Some(String::from_utf8(record.name().to_vec()).unwrap_or_else(|_| "*".to_string()));
        let seq = record.sequence().as_ref().to_vec();
        records.push((name, seq));
    }
    idx.n_seq = records.len() as u32;
    // Precompute minimizers per sequence in parallel
    let is_hpc = (flag & 1) != 0;
    let minis_by_seq: Vec<Vec<Minimizer>> = records
        .par_iter()
        .enumerate()
        .map(|(rid, (_name, seq))| {
            let mut a: Vec<Minimizer> = Vec::new();
            if !seq.is_empty() {
                sketch_sequence(seq, w as usize, k as usize, rid as u32, is_hpc, &mut a);
            }
            a
        })
        .collect();
    // Compute total length and allocate packed sequence storage
    let total_len: u64 = records.iter().map(|(_, s)| s.len() as u64).sum();
    let words = kroundup64(((total_len + 7) / 8) as usize);
    idx.S.resize(words, 0);
    // Pack sequences and metadata, and add minimizers
    let mut sum_len: u64 = 0;
    for (rid, (name, seq)) in records.into_iter().enumerate() {
        // pack
        for (j, &ch) in seq.iter().enumerate() {
            let c = nt4(ch);
            let o = sum_len + j as u64;
            mm_seq4_set(&mut idx.S, o, c);
        }
        // meta
        idx.seq.push(IndexSeq{ name, offset: sum_len, len: seq.len() as u32, is_alt: false });
        // add minimizers for this rid
        idx.add_minimizers(&minis_by_seq[rid]);
        sum_len += seq.len() as u64;
    }
    // finalize buckets
    idx.post_process();
    Ok(idx)
}

```

```rust
use clap::{Parser, Subcommand};
use mm2rs::index::build_index_from_fasta;
use mm2rs::index::Index;
use mm2rs::seeds::{collect_query_minimizers, filter_query_minimizers, build_anchors_filtered};
use mm2rs::lchain::{chain_dp, chain_dp_all, ChainParams, select_and_filter_chains, merge_adjacent_chains_with_gap, rescue_long_join};
use mm2rs::paf::{paf_from_chain, write_paf, write_paf_many_with_scores};
use std::fs::File;
use noodles_fasta::io::Reader as FastaReader;
use std::io::Write;

#[derive(Parser, Debug)]
#[command(version, about = "mm2rs: Rust rewrite of minimap2 (WIP)")]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Subcommand, Debug)]
enum Commands {
    Index {
        fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'b', default_value_t = 14)]
        bucket_bits: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
            #[arg(short = 'd', long = "dump")] 
            dump: Option<String>,
    },
    Anchors {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Chain {
        ref_fasta: String,
        qry_fasta: String,
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'r', default_value_t = 5000)]
        bw: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
    },
    Align {
        ref_fasta: String,
        qry_fasta: String,
        // Indexing basics
        #[arg(short = 'w', default_value_t = 10)]
        w: i32,
        #[arg(short = 'k', default_value_t = 15)]
        k: i32,
        #[arg(short = 'H', long = "hpc", default_value_t = false)]
        hpc: bool,
        // Mapping
        #[arg(short = 'f', default_value_t = 2e-4f32)]
        frac_top_repetitive: f32, // -f
        #[arg(short = 'g', default_value_t = 5000)]
        max_gap: i32, // -g
        #[arg(short = 'r')]
        r: Option<String>, // -r NUM[,NUM]
        #[arg(short = 'n', default_value_t = 3)]
        min_cnt: i32, // -n
        #[arg(short = 'm', default_value_t = 40)]
        min_chain_score: i32, // -m
        #[arg(short = 'M', long, default_value_t = 0.5)]
        mask_level: f32, // -M
        #[arg(short = 'p', long, default_value_t = 0.8)]
        pri_ratio: f32, // -p
        #[arg(short = 'N', long, default_value_t = 5)]
        best_n: usize, // -N
        #[arg(short = 'x')]
        preset: Option<String>, // -x
        // I/O
        #[arg(short = 'a', default_value_t = false)]
        out_sam: bool, // -a (ignored; PAF only for now)
        #[arg(short = 'o')]
        output: Option<String>, // -o FILE
    },
}

fn read_fasta_first(path: &str) -> anyhow::Result<(String, Vec<u8>)> {
    use std::io::BufReader;
    let mut reader = FastaReader::new(BufReader::new(File::open(path)?));
    if let Some(result) = reader.records().next() {
        let record = result?;
        let name = String::from_utf8(record.name().to_vec()).unwrap_or_else(|_| "*".to_string());
        let seq = record.sequence().as_ref().to_vec();
        Ok((name, seq))
    } else {
        Ok(("*".to_string(), Vec::new()))
    }
}

fn default_chain_params(k: i32) -> ChainParams {
    let chain_gap_scale = 0.8f32; // minimap2 default
    let chn_pen_gap = 0.01f32 * chain_gap_scale * (k as f32); // opt->chain_gap_scale*0.01*k
    ChainParams{
        max_dist_x: 5000,
        max_dist_y: 5000,
        bw: 500,
        max_chain_iter: 5000,
        min_chain_score: 40,
        min_cnt: 3,
        chn_pen_gap,
        chn_pen_skip: 0.0,
        max_chain_skip: 25,
        max_drop: 500, // ~bw
        bw_long: 20000,
        rmq_rescue_size: 1000,
        rmq_rescue_ratio: 0.1,
    }
}

fn apply_preset(preset: &str, w: &mut i32, k: &mut i32, _hpc: &mut bool) {
    match preset {
        // Minimal presets for convenience; extend as needed
        "map-ont" => { *k = 15; *w = 10; },
        "map-hifi" | "lr:hq" => { *k = 19; *w = 10; },
        "sr" => { *k = 21; *w = 11; },
        _ => {},
    }
}

fn load_index_auto(path: &str, w: i32, k: i32, b: i32, flag: i32) -> anyhow::Result<Index> {
    match Index::load_from_file(path) {
        Ok(idx) => Ok(idx),
        Err(_) => build_index_from_fasta(path, w, k, b, flag),
    }
}

fn main() -> anyhow::Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Commands::Index{ fasta, w, k, bucket_bits, hpc, dump } => {
            let flag = if hpc {1} else {0};
            let idx = build_index_from_fasta(&fasta, w, k, bucket_bits, flag)?;
            let (n_keys, avg_occ, avg_spacing, total_len) = idx.stats();
            println!("kmer size: {}; skip: {}; is_hpc: {}; #seq: {}", k, w, if hpc {1} else {0}, idx.n_seq);
            println!("distinct minimizers: {} (avg occ {:.2}) avg spacing {:.3} total length {}", n_keys, avg_occ, avg_spacing, total_len);
            if let Some(path) = dump.as_ref() {
                if path.ends_with(".mmi") { idx.save_to_mmi(path)?; } else { idx.save_to_file(path)?; }
            }
        }
        Commands::Anchors{ ref_fasta, qry_fasta, w, k, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            println!("anchors: {}", anchors.len());
            for a in anchors.iter().take(10) { println!("x=0x{:016x} y=0x{:016x}", a.x, a.y); }
        }
        Commands::Chain{ ref_fasta, qry_fasta, w, k, bw, hpc } => {
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (_qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(2e-4f32);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k); p.bw = bw; // allow override bw
            let chain = chain_dp(&anchors, &p);
            println!("best_chain_len: {}", chain.len());
            if let (Some(&st), Some(&en)) = (chain.first(), chain.last()) {
                println!("start: x=0x{:016x} y=0x{:016x}", anchors[st].x, anchors[st].y);
                println!("end:   x=0x{:016x} y=0x{:016x}", anchors[en].x, anchors[en].y);
            }
        }
        Commands::Align{ ref_fasta, qry_fasta, mut w, mut k, mut hpc, frac_top_repetitive, max_gap, r, min_cnt, min_chain_score, mask_level, pri_ratio, best_n, preset, out_sam: _out_sam, output } => {
            if let Some(px) = preset.as_ref() { apply_preset(px, &mut w, &mut k, &mut hpc); }
            let flag = if hpc {1} else {0};
            let idx = load_index_auto(&ref_fasta, w, k, 14, flag)?;
            let (qname, q) = read_fasta_first(&qry_fasta)?;
            let mut mv = collect_query_minimizers(&q, w as usize, k as usize);
            filter_query_minimizers(&mut mv, 10, 0.01);
            let mut mid_occ = idx.calc_mid_occ(frac_top_repetitive);
            if mid_occ < 10 { mid_occ = 10; }
            let anchors = build_anchors_filtered(&idx, &mv, q.len() as i32, mid_occ);
            let mut p = default_chain_params(k);
            p.max_dist_x = max_gap; p.max_dist_y = max_gap;
            p.min_cnt = min_cnt; p.min_chain_score = min_chain_score;
            if let Some(r_opt) = r.as_ref() {
                if !r_opt.is_empty() {
                    let parts: Vec<&str> = r_opt.split(',').collect();
                    if let Some(bw_str) = parts.get(0) { if let Ok(v) = bw_str.parse::<i32>() { p.bw = v; } }
                    if let Some(bw_long_str) = parts.get(1) { if let Ok(v) = bw_long_str.parse::<i32>() { p.bw_long = v; } }
                }
            }
            let (chains_all, scores_all) = chain_dp_all(&anchors, &p);
            let mut lines: Vec<String> = Vec::new();
            if chains_all.is_empty() {
                let chain = chain_dp(&anchors, &p);
                if let Some(rec) = paf_from_chain(&idx, &anchors, &chain, &qname, &q) { lines.push(write_paf(&rec)); }
            } else {
                let (chains_rescued, scores_rescued) = rescue_long_join(&anchors, &chains_all, &scores_all, &p, q.len() as i32);
                let chains_merged = merge_adjacent_chains_with_gap(&anchors, &chains_rescued, p.max_dist_y, p.max_dist_y);
                let (chains, _scores, _is_pri, s1, s2) = select_and_filter_chains(&anchors, &chains_merged, &scores_rescued, mask_level, pri_ratio, best_n);
                lines.extend(write_paf_many_with_scores(&idx, &anchors, &chains, s1, s2, &qname, &q));
            }
            if let Some(path) = output.as_ref() {
                if path != "-" {
                    let mut f = File::create(path)?;
                    for l in lines { writeln!(f, "{}", l)?; }
                } else {
                    for l in lines { println!("{}", l); }
                }
            } else {
                for l in lines { println!("{}", l); }
            }
        }
    }
    Ok(())
}

```

 C  minimap2  MMI 

-  `Index::save_to_mmi(path)` C  `mm_idx_dump`  `"MMI\x02"` 5  u32w,k,b,n_seq,flag u8  +  + u32  `n`(u32)`p` (u64n)hash (u32)hash (u64,u64)size `S`(u32((sum_len+7)/8)) C  `mm_idx_load` 
- CLI`mm2rs index -d xxx.mmi ref.fa`  `.mmi` MMI mm2rs 


- 
  - cd /home/xzg/project/minimap2_rs2/mm2rs && cargo build --release | cat
-  C 
  - /home/xzg/project/minimap2_rs2/mm2rs/target/release/mm2rs index -d /home/xzg/project/minimap2_rs2/test/ref.mmi /home/xzg/project/minimap2_rs2/test/genome.fa
-  C minimap2 
  - /home/xzg/project/minimap2_rs2/minimap2/minimap2 -v0 -d /home/xzg/project/minimap2_rs2/test/ref.mmi /home/xzg/project/minimap2_rs2/test/genome.fa


-  C  NO_SEQC  `flag`  `S`
-  hash  position C 


-  `save_to_mmi`  CLI C minimap2  `mm_idx_load` 

